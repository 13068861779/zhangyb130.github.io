<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【NDK系列13】Cmake详解 CMakeLists.txt详细配置</title>
      <link href="/android/ndk/ndk-13/"/>
      <url>/android/ndk/ndk-13/</url>
      
        <content type="html"><![CDATA[<p>作为Android开发者，还是乖乖的使用Cmake进行NDK的开发好了</p><a id="more"></a><h2 id="一、CMake简介"><a href="#一、CMake简介" class="headerlink" title="一、CMake简介"></a>一、CMake简介</h2><p>CMake是一个比make更高级的编译配置工具，它可以根据不同平台、不同的编译器，生成相应的Makefile或者vcproj项目。从而达到跨平台的目的。</p><p>Android Studio利用CMake生成的是ninja，ninja是一个小型的关注速度的构建系统。我们不需要关心ninja的脚本，知道怎么配置cmake就可以了。从而可以看出cmake其实是一个跨平台的支持产出各种不同的构建脚本的一个工具。</p><p>在android studio 2.2及以上，构建原生库的默认工具是 CMake。</p><h2 id="二、基本命令"><a href="#二、基本命令" class="headerlink" title="二、基本命令"></a>二、基本命令</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#cmake最低版本</span><br><span class="line">cmake_minimum_required(VERSION <span class="number">3.6</span><span class="number">.0</span>)</span><br><span class="line"></span><br><span class="line">#指定项目</span><br><span class="line">project(Main)</span><br><span class="line"></span><br><span class="line">add_executable(demo demo.cpp) # 生成可执行文件</span><br><span class="line">add_library(common STATIC util.cpp) # 生成静态库</span><br><span class="line">add_library(common SHARED util.cpp) # 生成动态库或共享库</span><br></pre></td></tr></table></figure><p><strong>搜索c/cpp文件</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 搜索当前目录下的所有.cpp文件， 但不能查找子目录</span><br><span class="line">aux_source_directory(. SRC_LIST) </span><br><span class="line">add_library(demo $&#123;SRC_LIST&#125;)</span><br><span class="line"></span><br><span class="line">#也可以 </span><br><span class="line">file(GLOB DIR_SRCS *.c)</span><br><span class="line">add_executable(main $&#123;DIR_SRCS&#125;)</span><br></pre></td></tr></table></figure><p><strong>使用子目录中的CMakeList</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 添加 child 子目录下的cmakelist</span><br><span class="line">add_subdirectory(child)</span><br><span class="line"># 指定生成目标 </span><br><span class="line">add_library(main $&#123;DIR_SRCS&#125;)</span><br><span class="line"># 添加链接库</span><br><span class="line">target_link_libraries(main child)</span><br><span class="line"><span class="comment">//--------------------------------------</span></span><br><span class="line"># child中设置</span><br><span class="line">aux_source_directory(. DIR_LIB_SRCS)</span><br><span class="line"># 生成链接库 默认生成静态库</span><br><span class="line">add_library (child $&#123;DIR_LIB_SRCS&#125;)</span><br><span class="line">#指定编译为静态库</span><br><span class="line">add_library (child STATIC $&#123;DIR_LIB_SRCS&#125;)</span><br></pre></td></tr></table></figure><p><strong>设置预编译宏</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#设置预编译宏 cflag和cxxflag</span><br><span class="line">set(CMAKE_C_FLAGS <span class="string">"$&#123;CMAKE_C_FLAGS&#125; -DTEST"</span>  )</span><br><span class="line">set(CMAKE_Cxx_FLAGS <span class="string">"$&#123;CMAKE_Cxx_FLAGS&#125; -DTEST"</span>  )</span><br></pre></td></tr></table></figure><p><strong>引入头文件</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#这样就可以使用 #include &lt;xx&gt; 引入 </span><br><span class="line">#否则需要使用 #include "path/xx" </span><br><span class="line">include_directories( imported-lib/include/ )</span><br></pre></td></tr></table></figure><p><strong>逻辑判断语句</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#逻辑判断 计较字符串</span><br><span class="line">set(ANDROID_ABI <span class="string">"areambi-v7a"</span>)</span><br><span class="line"><span class="keyword">if</span>($&#123;ANDROID_ABI&#125; STREQUAL <span class="string">"areambi"</span>)</span><br><span class="line">  message(<span class="string">"armv5"</span>)</span><br><span class="line">elseif($&#123;ANDROID_ABI&#125; STREQUAL <span class="string">"areambi-v7a"</span>)</span><br><span class="line">message(<span class="string">"armv7a"</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line"></span><br><span class="line">endif()</span><br></pre></td></tr></table></figure><h2 id="三、-build-gradle配置"><a href="#三、-build-gradle配置" class="headerlink" title="三、 build.gradle配置"></a>三、 build.gradle配置</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//还可以在gradle中使用 arguments  设置一些配置</span></span><br><span class="line">externalNativeBuild &#123;</span><br><span class="line">      cmake &#123;</span><br><span class="line">        <span class="built_in">arguments</span> <span class="string">"-DANDROID_TOOLCHAIN=clang"</span>,<span class="comment">//使用的编译器clang/gcc</span></span><br><span class="line">                  <span class="string">"-DANDROID_STL=gnustl_static"</span> <span class="comment">//cmake默认就是 gnustl_static</span></span><br><span class="line">        cFlags <span class="string">""</span> <span class="comment">//这里也可以指定cflag和cxxflag,效果和之前的cmakelist里使用一样</span></span><br><span class="line">        cppFlags <span class="string">""</span> </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="四、-注意事项"><a href="#四、-注意事项" class="headerlink" title="四、 注意事项"></a>四、 注意事项</h2><ol><li><p>​    使用Android.mk在 &gt;=6.0 设备上不能再使用预编译动态库(静态库没问题)：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION <span class="number">3.4</span><span class="number">.1</span>)</span><br><span class="line"></span><br><span class="line">file(GLOB SOURCE *.c )</span><br><span class="line">add_library(</span><br><span class="line">             hello-jni</span><br><span class="line">             SHARED</span><br><span class="line">            $&#123;SOURCE&#125; )</span><br><span class="line">            </span><br><span class="line">#这段配置在6.0依然没问题 </span><br><span class="line">set(CMAKE_C_FLAGS <span class="string">"$&#123;CMAKE_C_FLAGS&#125; -L[SO所在目录]"</span>)</span><br><span class="line"></span><br><span class="line">#这段配置只能在6.0以下使用 </span><br><span class="line">#add_library(Test SHARED IMPORTED)</span><br><span class="line">#set_target_properties(Test PROPERTIES IMPORTED_LOCATION [SO绝对地址])</span><br><span class="line"></span><br><span class="line">target_link_libraries(  hello-jni Test )</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>存在两个动态库<code>libhello-jni.so</code> 与 <code>libTest.so</code>。</p><p>libhello-jni.so<code>依赖于</code>libTest.so<code>(使用NDK下的</code>ndk-depends`可查看依赖关系)，则：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&lt;=5.0:</span></span><br><span class="line">System.loadLibrary(<span class="string">"Test"</span>);</span><br><span class="line">System.loadLibrary(<span class="string">"hello-jni"</span>);</span><br><span class="line"><span class="comment">//&gt;=6.0:</span></span><br><span class="line">System.loadLibrary(<span class="string">"hello-jni"</span>);</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> NDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【NDK系列12】Makefile Android.mk Application.mk 详解</title>
      <link href="/android/ndk/ndk-12/"/>
      <url>/android/ndk/ndk-12/</url>
      
        <content type="html"><![CDATA[<p>我们在使用第三方库时，很多都提供makefile，我们需要读懂他们并且适当的修改他们，另外虽说现在google推荐使用cmake，但是如果遇见Android.mk还是需要能够读懂。</p><a id="more"></a><h2 id="一、什么是Makefile"><a href="#一、什么是Makefile" class="headerlink" title="一、什么是Makefile"></a>一、什么是Makefile</h2><p>无论是c、c++首先要把源文件编译成中间代码文件，在Windows下也就是 .obj 文件，UNIX下是 .o 文件，即 Object File，这个动作叫做<code>编译（compile）</code>，然后再把大量的Object File合成执行文件或者静动态库，这个动作叫作<code>链接（link）</code>。</p><p>一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，如何进行链接等等操作。</p><p>makefile 就是“自动化编译”，告诉make命令如何编译和链接,即make工具的配置脚本。</p><p>默认的情况下，gun make命令会在当前目录下按顺序找寻文件</p><p>“GNUmakefile”</p><p>“makefile”</p><p>“Makefile”</p><p>最好不要用“GNUmakefile”，这个文件是GNU的make识别的（Windows Nmake就不识别）</p><p> 当然，也可以使用别的文件名来书写Makefile，比如：“Make.Linux”，“Make.android”。这样在使用时候就需要 <code>make -f XX 或者 make --file XX。</code></p><h2 id="二、Makefile规则"><a href="#二、Makefile规则" class="headerlink" title="二、Makefile规则"></a>二、Makefile规则</h2><h3 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1. 基本用法"></a>1. 基本用法</h3><p>在Makefile中的命令，必须要以[Tab]键开始。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">在Makefile中的命令，必须要以[Tab]键开始。</span><br><span class="line"></span><br><span class="line">target : prerequisites ...(预备知识，先决条件)</span><br><span class="line">command（指令）</span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line">      target也就是一个目标文件，可以是Object File，也可以是执行文件。还可以是一个标签。</span><br><span class="line">      prerequisites 要生成那个target所需要的文件或是其他target。</span><br><span class="line">      command也就是make需要执行的命令。（任意的Shell命令）</span><br></pre></td></tr></table></figure><p>如下例子</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># g++ -o  指定生成可执行文件的名称</span></span><br><span class="line"><span class="comment"># 下面的方法就是将main.o和test.o编译成test可执行程序test</span></span><br><span class="line"><span class="section">test:main.o test1.o</span></span><br><span class="line">g++ -o test main.o test1.o</span><br></pre></td></tr></table></figure><p>当然也可以直接编译cpp</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># \ 是换行连接符 便于Makefile的易读,不用都挤在一行</span></span><br><span class="line"><span class="section">test2:</span></span><br><span class="line">g++ -o test2 main.cpp \</span><br><span class="line">test1.cpp</span><br></pre></td></tr></table></figure><p>clean </p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">rm test main.o test.o</span><br></pre></td></tr></table></figure><p>打印数据</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">print:</span></span><br><span class="line">echo <span class="string">"hello world"</span></span><br></pre></td></tr></table></figure><h3 id="2-变量"><a href="#2-变量" class="headerlink" title="2. 变量"></a>2. 变量</h3><p>如果比较复杂的情况，比如文件很多，target目标比较多，那么我们如果来修改，比如增加一个.cpp文件，</p><p>那可能需要在很多地方都写一下，也容易出错。为了易于维护，可以在makefile中使用变量。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#声明变量</span></span><br><span class="line">objects=main.o T1.o</span><br><span class="line"><span class="comment">#mac上自动编译 main.o</span></span><br><span class="line"><span class="section">test:$&#123;objects&#125;</span></span><br><span class="line">g++ -o test $&#123;objects&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm test $&#123;objects&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#======================================</span></span><br><span class="line"><span class="comment"># *.c 表示所有后缀为c的文件。</span></span><br><span class="line"><span class="comment"># 让通配符在变量中(当前目录下所有 .c 文件)</span></span><br><span class="line">objects = <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line">test : $&#123;objects&#125;</span><br><span class="line">        gcc -o test $&#123;objects&#125;</span><br><span class="line">clean :</span><br><span class="line">        rm test $&#123;obects&#125;</span><br></pre></td></tr></table></figure><h3 id="3-include"><a href="#3-include" class="headerlink" title="3. include"></a>3. include</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> make.clean</span><br><span class="line"></span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line"></span><br><span class="line">mk=make.clean</span><br><span class="line"><span class="keyword">include</span> $&#123;mk&#125;</span><br></pre></td></tr></table></figure><h3 id="4-文件搜索"><a href="#4-文件搜索" class="headerlink" title="4. 文件搜索"></a>4. 文件搜索</h3><p>在一些大的工程中，有大量的源文件存放在不同的目录中,最好的方法是把一个路径告诉make，让make在自动去找。<br>Makefile文件中的特殊变量<code>VPATH</code>就是完成这个功能的</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#默认先查找当前目录再查找当前目录下的a、b、c目录</span></span><br><span class="line">VPATH = a:b:c</span><br><span class="line">OBJ=a.o b.o c.o main.o</span><br><span class="line"></span><br><span class="line">test : <span class="variable">$(OBJ)</span></span><br><span class="line">        gcc -o  test  <span class="variable">$(OBJ)</span></span><br><span class="line">clean :</span><br><span class="line">        rm test <span class="variable">$(OBJ)</span></span><br></pre></td></tr></table></figure><h3 id="5-预定义变量"><a href="#5-预定义变量" class="headerlink" title="5. 预定义变量"></a>5. 预定义变量</h3><table><thead><tr><th>命令变量</th><th>含义</th></tr></thead><tbody><tr><td>AR</td><td>函数库的打包程序，默认为”ar”</td></tr><tr><td>AS</td><td>汇编语言编译程序,默认为”as”</td></tr><tr><td>CC</td><td>C语言编译程序,默认命令是”cc”</td></tr><tr><td>CXX</td><td>C++语言编译程序,默认命令是”g++”</td></tr><tr><td>RM</td><td>文件删除程序的名称,默认值为 rm –f</td></tr><tr><td>ARFLAGS</td><td>库文件维护程序的选项,无默认值</td></tr><tr><td>ASFLAGS</td><td>汇编程序的选项,无默认值</td></tr><tr><td>CFLAGS</td><td>C 编译器的选项,无默认值</td></tr><tr><td>CPPFLAGS</td><td>C 预编译的选项,无默认值</td></tr><tr><td>CXXFLAGS</td><td>C++编译器的选项,无默认值</td></tr></tbody></table><h3 id="6-自动变量"><a href="#6-自动变量" class="headerlink" title="6. 自动变量"></a>6. 自动变量</h3><blockquote><p>$@  <code>target的名字</code>  </p></blockquote><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">main.o:main.c</span></span><br><span class="line">gcc -c main.c -o main.o</span><br><span class="line"><span class="comment">#使用 $@ 代替 main.o</span></span><br><span class="line"><span class="section">main.o:main.c</span></span><br><span class="line">gcc -c main.c -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><blockquote><p>$&lt;  <code>target依赖的第一个依赖文件名</code></p></blockquote><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">main.o:main.c a.h b.h</span></span><br><span class="line">gcc -c main.c -o main.o</span><br><span class="line"><span class="comment">#使用 $&lt; 代替 main.c</span></span><br><span class="line"><span class="section">main.o:main.c a.h b.h</span></span><br><span class="line">gcc -c <span class="variable">$&lt;</span> -o main.o</span><br></pre></td></tr></table></figure><table><thead><tr><th>变量</th><th>说明</th></tr></thead><tbody><tr><td>$*</td><td>不包含扩展名的target文件名称</td></tr><tr><td>$+</td><td>所有的依赖文件,以空格分开,并以出现的先后为序,可能包含 重复的依赖文件</td></tr><tr><td>$?</td><td>所有时间戳比target文件晚的依赖文件,并以空格分开</td></tr><tr><td>$^</td><td>所有不重复的依赖文件,以空格分开</td></tr></tbody></table><h3 id="7-条件语句"><a href="#7-条件语句" class="headerlink" title="7. 条件语句"></a>7. 条件语句</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CC)</span>,gcc)</span><br><span class="line">        <span class="variable">$(CC)</span> -o foo <span class="variable">$(objects)</span> <span class="variable">$(libs_for_gcc)</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        <span class="variable">$(CC)</span> -o foo <span class="variable">$(objects)</span> <span class="variable">$(normal_libs)</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><h3 id="8-输出信息"><a href="#8-输出信息" class="headerlink" title="8. 输出信息"></a>8. 输出信息</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AAA=123456</span><br><span class="line"><span class="comment">#输出变量AAA</span></span><br><span class="line"><span class="variable">$(<span class="built_in">warning</span> <span class="variable">$(AAA)</span>)</span></span><br><span class="line"><span class="variable">$(info <span class="variable">$(AAA)</span>)</span></span><br></pre></td></tr></table></figure><h2 id="三、Android-mk"><a href="#三、Android-mk" class="headerlink" title="三、Android.mk"></a>三、Android.mk</h2><p>微小 GNU makefile 片段。</p><p>将源文件分组为<em>模块</em>。 模块是静态库、共享库或独立可执行文件。 可在每个 <code>Android.mk</code> 文件中定义一个或多个模块，也可在多个模块中使用同一个源文件。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#源文件在的位置。宏函数 my-dir 返回当前目录</span></span><br><span class="line">LOCAL_PATH := <span class="variable">$(<span class="built_in">call</span> my-<span class="built_in">dir</span>)</span></span><br><span class="line"><span class="comment">#可为您清除变量</span></span><br><span class="line"><span class="comment">#不会清理 LOCAL_PATH 变量</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(CLEAR_VARS)</span></span><br><span class="line"><span class="comment">#存储您要构建的模块的名称 每个模块名称必须唯一，且不含任何空格</span></span><br><span class="line"><span class="comment">#如果模块名称的开头已是 lib，则构建系统不会附加额外的前缀 lib；而是按原样采用模块名称，并添加 .so 扩展名。</span></span><br><span class="line">LOCAL_MODULE := hello-jni</span><br><span class="line"><span class="comment">#包含要构建到模块中的 C 和/或 C++ 源文件列表 以空格分开</span></span><br><span class="line">LOCAL_SRC_FILES := hello-jni.c</span><br><span class="line"><span class="comment">#构建动态库</span></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_SHARED_LIBRARY)</span></span><br></pre></td></tr></table></figure><h3 id="1-变量和宏"><a href="#1-变量和宏" class="headerlink" title="1. 变量和宏"></a>1. 变量和宏</h3><p>定义自己的任意变量。在定义变量时请注意，NDK 构建系统会预留以下变量名称：</p><ul><li>以 <code>LOCAL_</code> 开头的名称，例如 <code>LOCAL_MODULE</code>。</li><li>以 <code>PRIVATE_</code>、<code>NDK_</code> 或 <code>APP</code> 开头的名称。构建系统在内部使用这些变量。</li><li>小写名称，例如 <code>my-dir</code>。构建系统也是在内部使用这些变量。</li></ul><p>如果为了方便而需要在 <code>Android.mk</code> 文件中定义自己的变量，建议在名称前附加 <code>MY_</code>。</p><h3 id="2-常用内置变量"><a href="#2-常用内置变量" class="headerlink" title="2. 常用内置变量"></a>2. 常用内置变量</h3><table><thead><tr><th>变量名</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td>BUILD_STATIC_LIBRARY</td><td>构建静态库的Makefile脚本</td><td>include $(BUILD_STATIC_LIBRARY)</td></tr><tr><td>PREBUILT_SHARED_LIBRARY</td><td>预编译共享库的Makeifle脚本</td><td>include $(PREBUILT_SHARED_LIBRARY)</td></tr><tr><td>PREBUILT_STATIC_LIBRARY</td><td>预编译静态库的Makeifle脚本</td><td>include $(PREBUILT_STATIC_LIBRARY)</td></tr><tr><td>TARGET_PLATFORM</td><td>Android API 级别号</td><td>TARGET_PLATFORM := android-22</td></tr><tr><td>TARGET_ARCH</td><td>CUP架构</td><td>arm arm64 x86 x86_64</td></tr><tr><td>TARGET_ARCH_ABI</td><td>CPU架构</td><td>armeabi  armeabi-v7a  arm64-v8a</td></tr></tbody></table><p><strong>模块描述变量</strong></p><table><thead><tr><th>变量名</th><th>描述</th><th>例</th></tr></thead><tbody><tr><td>LOCAL_MODULE_FILENAME</td><td>覆盖构建系统默认用于其生成的文件的名称</td><td>LOCAL_MODULE := foo LOCAL_MODULE_FILENAME := libnewfoo</td></tr><tr><td>LOCAL_CPP_FEATURES</td><td>特定 C++ 功能</td><td>支持异常:LOCAL_CPP_FEATURES := exceptions</td></tr><tr><td>LOCAL_C_INCLUDES</td><td>头文件目录查找路径</td><td>LOCAL_C_INCLUDES := $(LOCAL_PATH)/include</td></tr><tr><td>LOCAL_CFLAGS</td><td>构建 C <em>和</em> C++ 的编译参数</td><td></td></tr><tr><td>LOCAL_CPPFLAGS</td><td>c++</td><td></td></tr><tr><td>LOCAL_STATIC_LIBRARIES</td><td>当前模块依赖的静态库模块列表</td><td></td></tr><tr><td>LOCAL_SHARED_LIBRARIES</td><td></td><td></td></tr><tr><td>LOCAL_WHOLE_STATIC_LIBRARIES</td><td>–whole-archive</td><td>将未使用的函数符号也加入编译进入这个模块</td></tr><tr><td>LOCAL_LDLIBS</td><td>依赖 系统库</td><td>LOCAL_LDLIBS := -lz</td></tr></tbody></table><p>导出给引入模块的模块使用</p><p>LOCAL_EXPORT_CFLAGS</p><p>LOCAL_EXPORT_CPPFLAGS</p><p>LOCAL_EXPORT_C_INCLUDES</p><p>LOCAL_EXPORT_LDLIBS</p><h3 id="3-引入其他模块"><a href="#3-引入其他模块" class="headerlink" title="3. 引入其他模块"></a>3. 引入其他模块</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将一个新的路径加入NDK_MODULE_PATH变量</span></span><br><span class="line"><span class="comment">#NDK_MODULE_PATH 变量是系统环境变量</span></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> import-add-path,<span class="variable">$(LOCAL_PATH)</span>/platform/third_party/android/prebuilt)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#包含CocosDenshion/android目录下的mk文件</span></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> import-module,CocosDenshion/android)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#这里即为 我需要引入 CocosDenshion/android 下面的Android.mk</span></span><br><span class="line"><span class="comment">#CocosDenshion/android 的路径会从 $(LOCAL_PATH)/platform/third_party/android/prebuilt 去查找</span></span><br></pre></td></tr></table></figure><h2 id="四、Application-mk"><a href="#四、Application-mk" class="headerlink" title="四、Application.mk"></a>四、Application.mk</h2><h3 id="1-配置"><a href="#1-配置" class="headerlink" title="1. 配置"></a>1. 配置</h3><p>同样是GNU Makefile 片段,在Application.mk中定义一些全局(整个项目)的配置</p><p><strong>APP_OPTIM</strong></p><p>将此可选变量定义为 <code>release</code> 或 <code>debug</code>。在构建应用的模块时可使用它来更改优化级别。发行模式是默认模式，可生成高度优化的二进制文件。调试模式会生成未优化的二进制文件，更容易调试。</p><p><strong>APP_CFLAGS</strong></p><p>为任何模块编译任何 C 或 C++ 源代码时传递到编译器的一组 C 编译器标志</p><p><strong>APP_CPPFLAGS</strong></p><p>构建 C++ 源文件时传递到编译器的一组 C++ 编译器标志。</p><p><strong>APP_ABI</strong></p><p>需要生成的cpu架构(ndk r17之上 只支持：armeabi-v7a, arm64-v8a, x86, x86_64)</p><p><strong>APP_PLATFORM</strong></p><p>此变量包含目标 Android 平台的名称。例如，<code>android-3</code> 指定 Android 1.5 系统映像</p><p><strong>APP_STL</strong></p><p>默认情况下，NDK 构建系统为 Android 系统提供的最小 C++ 运行时库 (<code>system/lib/libstdc++.so</code>) 提供 C++ 功能。 </p><h3 id="2-APP-ABI架构"><a href="#2-APP-ABI架构" class="headerlink" title="2. APP_ABI架构"></a>2. APP_ABI架构</h3><p>不同 Android 手机使用不同的 CPU，因此支持不同的指令集。</p><p><strong>armeabi</strong></p><p>此 ABI 适用于基于 ARM、至少支持 ARMv5TE 指令集的 CPU。此 ABI 不支持硬件辅助的浮点计算。 相反，所有浮点运算都使用编译器 <code>libgcc.a</code> 静态库中的软件帮助程序函数。</p><p><strong>armeabi-v7a</strong></p><p><code>armeabi-v7a</code> ABI 使用 <code>-mfloat-abi=softfp</code> 开关强制实施规则，要求编译器在函数调用时必须传递核心寄存器对中的所有双精度值，而不是专用浮点值。 系统可以使用 FP 寄存器执行所有内部计算。 这样可极大地加速计算。</p><p>如果要以 armeabi-v7a ABI 为目标，则必须设置下列标志：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS= -march=armv7-a -mfloat-abi=softfp -mfpu=vfpv3-d16</span><br></pre></td></tr></table></figure><p><strong>arm64-v8a</strong></p><p>此 ABI 适用于基于 ARMv8、支持 AArch64 的 CPU。它还包含 NEON 和 VFPv4 指令集。</p><p><strong>x86</strong></p><p>此 ABI 适用于支持通常称为“x86”或“IA-32”的指令集的 CPU。设置的标志如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-march=i686 -mtune=intel -mssse3 -mfpmath=sse -m32</span><br></pre></td></tr></table></figure><p><strong>x86_64</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-march=x86-64 -msse4.2 -mpopcnt -m64 -mtune=intel</span><br></pre></td></tr></table></figure><p>现在手机主要是armeabi-v7a。查看手机cpu：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb shell cat /proc/cpuinfo</span><br><span class="line">adb shell getprop ro.product.cpu.abi</span><br></pre></td></tr></table></figure><p>apk在安装的时候，如果手机是armeabi-v7a的，则会首先查看apk中是否存在armeabi-v7a目录，如果没有就会查找armeabi。</p><p><strong>保证cpu目录下so数量一致。</strong></p><pre><code>如果目标是armeabi-v7a，但是拥有一个armeabi的，也可以把它放到armeabi-v7a目录下。但是反过来不行</code></pre><table><thead><tr><th>ABI(横 so)/CPU(竖 手机)</th><th>armeabi</th><th>armeabi-v7a</th><th>arm64-v8a</th><th>x86</th><th>x86_64</th></tr></thead><tbody><tr><td>ARMV5</td><td>支持</td><td></td><td></td><td></td><td></td></tr><tr><td>ARMV7</td><td>支持</td><td>支持</td><td></td><td></td><td></td></tr><tr><td>ARMV8</td><td>支持</td><td>支持</td><td>支持</td><td></td><td></td></tr><tr><td>X86</td><td></td><td></td><td></td><td>支持</td><td></td></tr><tr><td>X86_64</td><td></td><td></td><td></td><td>支持</td><td>支持</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> NDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【NDK系列11】编译器 clang gcc g++</title>
      <link href="/android/ndk/ndk-11/"/>
      <url>/android/ndk/ndk-11/</url>
      
        <content type="html"><![CDATA[<p>了解c/c++编译器的基本使用，能够在后续移植第三方框架进行交叉编译时，清楚的了解应该传递什么参数。</p><a id="more"></a><h2 id="1-gcc-g-clang"><a href="#1-gcc-g-clang" class="headerlink" title="1. gcc/g++/clang"></a>1. gcc/g++/clang</h2><p>了解c/c++编译器的基本使用，能够在后续移植第三方框架进行交叉编译时，清楚的了解应该传递什么参数。</p><h3 id="clang"><a href="#clang" class="headerlink" title="clang"></a>clang</h3><p>clang 是一个<code>C、C++、Object-C</code>的轻量级编译器。基于<code>LLVM</code> （LLVM是以C++编写而成的构架编译器的框架系统，可以说是一个用于开发编译器相关的库）</p><h3 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h3><p><code>GNU C</code>编译器。原本只能处理<code>C语言</code>，很快扩展，变得可处理<code>C++</code>。(GNU计划，又称革奴计划。目标是创建一套完全自由的操作系统)</p><h3 id="g"><a href="#g" class="headerlink" title="g++"></a>g++</h3><p><code>GNU c++</code>编译器</p><p>gcc、g++、clang都是编译器。</p><ul><li>gcc和g++都能够编译c/c++，但是编译时候行为不同。</li><li>clang也是一个编译器，对比gcc，它具有编译速度更快、编译产出更小等优点，但是某些软件在使用clang编译时候因为源码中内容的问题会出现错误。</li><li>clang++与clang就相当于gcc与g++。</li></ul><p>对于gcc与g++：</p><ol><li>后缀为<code>.c</code>的源文件，gcc把它当作是C程序，而g++当作是C++程序；后缀为<code>.cpp</code>的，两者都会认为是c++程序</li><li>g++会自动链接c++标准库stl，gcc不会</li><li>gcc不会定义__cplusplus宏，而g++会</li></ol><p><strong>linux</strong>安装gcc</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install build-essential #安装gcc、g++与make</span><br></pre></td></tr></table></figure><h2 id="2-编译器过程"><a href="#2-编译器过程" class="headerlink" title="2. 编译器过程"></a>2. 编译器过程</h2><p>一个C/C++文件要经过预处理(preprocessing)、编译(compilation)、汇编(assembly)、和连接(linking)才能变成可执行文件。</p><h3 id="1、预处理"><a href="#1、预处理" class="headerlink" title="1、预处理"></a>1、预处理</h3><p>​     gcc -E main.c  -o main.i </p><p>​     <code>-E</code>的作用是让gcc在预处理结束后停止编译。</p><p>​    预处理阶段主要处理include和define等。它把#include包含进来的.h 文件插入到#include所在的位置，把源程序中使用到的用#define定义的宏用实际的字符串代替</p><h3 id="2、编译阶段"><a href="#2、编译阶段" class="headerlink" title="2、编译阶段"></a>2、<strong>编译阶段</strong></h3><p>​    gcc -S main.i -o main.s</p><p>​     <code>-S</code>的作用是编译后结束，编译生成了汇编文件。</p><p>​    在这个阶段中，gcc首先要检查代码的规范性、是否有语法错误等，以确定代码的实际要做的工作，在检查无误后，gcc把代码翻译成汇编语言。</p><h3 id="3、汇编阶段"><a href="#3、汇编阶段" class="headerlink" title="3、汇编阶段"></a>3、<strong>汇编阶段</strong></h3><p>​    gcc -c main.s -o main.o</p><p>​    汇编阶段把 .s文件翻译成二进制机器指令文件.o,这个阶段接收.c, .i, .s的文件都没有问题。</p><h3 id="4、链接阶段"><a href="#4、链接阶段" class="headerlink" title="4、链接阶段"></a>4、<strong>链接阶段</strong></h3><p>​    gcc -o main main.s</p><p>​    链接阶段，链接的是<strong>函数库</strong>。在main.c中并没有定义”printf”的函数实现，且在预编译中包含进的”stdio.h”中也只有该函数的声明。系统把这些函数实现都被做到名为<code>libc.so</code>的动态库。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><strong>函数库一般分为静态库和动态库两种</strong></p><ul><li>静态库是指编译链接时，把库文件的代码全部加入到可执行文件中，因此生成的文件比较大，但在运行时也就不再需要库文件了。Linux中后缀名为”.a”。</li><li>动态库与之相反，在编译链接时并没有把库文件的代码加入到可执行文件中，而是在程序执行时由运行时链接文件加载库。Linux中后缀名为”.so”，如前面所述的libc.so就是动态库。gcc在编译时默认使用动态库。</li></ul><blockquote><p>静态库节省时间:不需要再进行动态链接，需要调用的代码直接就在代码内部</p><p>动态库节省空间:如果一个动态库被两个程序调用,那么这个动态库只需要在内存中</p><p>Java中在不经过封装的情况下只能直接使用动态库。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> NDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【NDK系列10】Java和c++交互  Jni初识</title>
      <link href="/android/ndk/ndk-10/"/>
      <url>/android/ndk/ndk-10/</url>
      
        <content type="html"><![CDATA[<p>JNI是一种本地编程接口。它允许运行在JAVA虚拟机中的JAVA代码和用其他编程语言，诸如C语言、C++、汇编，应用和库之间的交互操作。 不只是Android特有的东西</p><a id="more"></a><h2 id="一、Java调用c-方法"><a href="#一、Java调用c-方法" class="headerlink" title="一、Java调用c++方法"></a>一、Java调用c++方法</h2><p>静态加载so</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">"native-lib"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c++中和java中对应方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">native11</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对应上面的java方法</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">JNIEXPORT jstring JNICALL</span><br><span class="line">Java_com_dds_anyndk_AnyNdk_native11(JNIEnv *env, jclass type, jint a, jstring str_, jfloat f) &#123;</span><br><span class="line">    <span class="comment">// 获得c字符串</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *str = env-&gt;GetStringUTFChars(str_, JNI_FALSE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> returnStr[<span class="number">100</span>];</span><br><span class="line">    <span class="comment">//格式化字符串</span></span><br><span class="line">    <span class="built_in">sprintf</span>(returnStr, <span class="string">"C++ string:%d,%s,%f"</span>, a, str, f);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放掉内存</span></span><br><span class="line">    env-&gt;ReleaseStringUTFChars(str_, str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> env-&gt;NewStringUTF(returnStr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CmakeLists.txt配置</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.4</span>.<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(</span><br><span class="line">        native-lib</span><br><span class="line">        SHARED</span><br><span class="line">        native11.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(</span><br><span class="line">        native-lib</span><br><span class="line">        log)</span><br></pre></td></tr></table></figure><h2 id="二、JNI数据类型"><a href="#二、JNI数据类型" class="headerlink" title="二、JNI数据类型"></a>二、JNI数据类型</h2><p><strong>JNIEXPORT</strong> 和 <strong>JNICALL</strong>，定义在<code>jni.h</code>头文件中。</p><p><strong>JNIEXPORT：</strong></p><p>在 Windows 中,定义为<code>__declspec(dllexport)</code>。因为Windows编译 dll 动态库规定，如果动态库中的函数要被外部调用，需要在函数声明中添加此标识，表示将该函数导出在外部可以调用。</p><p>在 Linux/Unix/Mac os/Android 这种 Like Unix系统中，定义为<strong>attribute</strong> ((visibility (“default”)))</p><p><strong>JNICALL:</strong></p><p>在类Unix中无定义，在Windows中定义为：<code>_stdcall</code> ，一种函数调用约定</p><p>类Unix系统中这两个宏可以省略不加。</p><p>类型对比如下</p><table><thead><tr><th>Java类型</th><th>本地类型</th><th>描述</th></tr></thead><tbody><tr><td>boolean</td><td>jboolean</td><td>C/C++8位整型</td></tr><tr><td>byte</td><td>jbyte</td><td>C/C++带符号的8位整型</td></tr><tr><td>char</td><td>jchar</td><td>C/C++无符号的16位整型</td></tr><tr><td>short</td><td>jshort</td><td>C/C++带符号的16位整型</td></tr><tr><td>int</td><td>jint</td><td>C/C++带符号的32位整型</td></tr><tr><td>long</td><td>jlong</td><td>C/C++带符号的64位整型</td></tr><tr><td>float</td><td>jfloat</td><td>C/C++32位浮点型</td></tr><tr><td>double</td><td>jdouble</td><td>C/C++64位浮点型</td></tr><tr><td>Object</td><td>jobject</td><td>任何Java对象，或者没有对应java类型的对象</td></tr><tr><td>Class</td><td>jclass</td><td>Class对象</td></tr><tr><td>String</td><td>jstring</td><td>字符串对象</td></tr><tr><td>Object[]</td><td>jobjectArray</td><td>任何对象的数组</td></tr><tr><td>boolean[]</td><td>jbooleanArray</td><td>布尔型数组</td></tr><tr><td>byte[]</td><td>jbyteArray</td><td>比特型数组</td></tr><tr><td>char[]</td><td>jcharArray</td><td>字符型数组</td></tr><tr><td>short[]</td><td>jshortArray</td><td>短整型数组</td></tr><tr><td>int[]</td><td>jintArray</td><td>整型数组</td></tr><tr><td>long[]</td><td>jlongArray</td><td>长整型数组</td></tr><tr><td>float[]</td><td>jfloatArray</td><td>浮点型数组</td></tr><tr><td>double[]</td><td>jdoubleArray</td><td>双浮点型数组</td></tr></tbody></table><p><strong>获取数组类型的数据</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">JNIEXPORT jstring JNICALL</span><br><span class="line">Java_com_dds_anyndk_AnyNdk_native11_12(JNIEnv *env, jclass type, jobjectArray strs,</span><br><span class="line">                                       jintArray ints_) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、 获得字符串数组</span></span><br><span class="line">    <span class="keyword">int32_t</span> str_length = env-&gt;GetArrayLength(strs);</span><br><span class="line">    LOGD(<span class="string">"字符串 数组长度:%d"</span>, str_length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str_length; ++i) &#123;</span><br><span class="line">        jstring str = jstring(env-&gt;GetObjectArrayElement(strs, i));</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *c_str = env-&gt;GetStringUTFChars(str, JNI_FALSE);</span><br><span class="line">        LOGD(<span class="string">"字符串有:%s"</span>, c_str);</span><br><span class="line">        <span class="comment">//使用完释放</span></span><br><span class="line">        env-&gt;ReleaseStringUTFChars(str, c_str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、获得基本数据类型数组</span></span><br><span class="line">    <span class="keyword">int32_t</span> int_length = env-&gt;GetArrayLength(ints_);</span><br><span class="line">    LOGD(<span class="string">"int 数组长度:%d"</span>, int_length);</span><br><span class="line">    jint *ints = env-&gt;GetIntArrayElements(ints_, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; int_length; i++) &#123;</span><br><span class="line">        LOGD(<span class="string">"int 数据有:%d"</span>, ints[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    env-&gt;ReleaseIntArrayElements(ints_, ints, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> env-&gt;NewStringUTF(<span class="string">"hello"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、C-C-反射Java"><a href="#三、C-C-反射Java" class="headerlink" title="三、C/C++反射Java"></a>三、C/C++反射Java</h2><p>在C/C++中反射创建Java的对象，调用Java的方法</p><p>基本数据类型的签名采用一系列大写字母来表示, 如下表所示:</p><table><thead><tr><th>Java类型</th><th>签名</th></tr></thead><tbody><tr><td>boolean</td><td>Z</td></tr><tr><td>short</td><td>S</td></tr><tr><td>float</td><td>F</td></tr><tr><td>byte</td><td>B</td></tr><tr><td>int</td><td>I</td></tr><tr><td>double</td><td>D</td></tr><tr><td>char</td><td>C</td></tr><tr><td>long</td><td>J</td></tr><tr><td>void</td><td>V</td></tr><tr><td>引用类型</td><td>L + 全限定名 + ;</td></tr><tr><td>数组</td><td>[+类型签名</td></tr></tbody></table><p>需要反射的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaHelper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"dds_native11"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//private和public 对jni开发来说没任何区别 都能反射调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">instanceMethod</span><span class="params">(String a, <span class="keyword">int</span> b, <span class="keyword">boolean</span> c)</span> </span>&#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"instanceMethod a="</span> + a + <span class="string">" b="</span> + b + <span class="string">" c="</span> + c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">(String a, <span class="keyword">int</span> b, <span class="keyword">boolean</span> c)</span> </span>&#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"staticMethod a="</span> + a + <span class="string">" b="</span> + b + <span class="string">" c="</span> + c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-反射调用方法"><a href="#1-反射调用方法" class="headerlink" title="1. 反射调用方法"></a>1. 反射调用方法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">JNIEXPORT jstring JNICALL</span><br><span class="line">Java_com_dds_anyndk_AnyNdk_native11_13(JNIEnv *env, jclass type) &#123;</span><br><span class="line">    jclass class_helper = env-&gt;FindClass(<span class="string">"com/dds/anyndk/JavaHelper"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反射调用静态方法</span></span><br><span class="line">    jmethodID method_staticMethod = env-&gt;GetStaticMethodID(class_helper, <span class="string">"staticMethod"</span>,</span><br><span class="line">                                                           <span class="string">"(Ljava/lang/String;IZ)V"</span>);</span><br><span class="line">    jstring staticStr = env-&gt;NewStringUTF(<span class="string">"C++调用静态方法"</span>);</span><br><span class="line">    env-&gt;CallStaticVoidMethod(class_helper, method_staticMethod, staticStr, <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反射调用构造方法</span></span><br><span class="line">    jmethodID constructMethod = env-&gt;GetMethodID(class_helper,<span class="string">"&lt;init&gt;"</span>,<span class="string">"()V"</span>);</span><br><span class="line"></span><br><span class="line">    jobject  helper = env-&gt;NewObject(class_helper,constructMethod);</span><br><span class="line">    jmethodID instanceMethod = env-&gt;GetMethodID(class_helper,<span class="string">"instanceMethod"</span>,<span class="string">"(Ljava/lang/String;IZ)V"</span>);</span><br><span class="line">    jstring instanceStr= env-&gt;NewStringUTF(<span class="string">"C++调用实例方法"</span>);</span><br><span class="line">    env-&gt;CallVoidMethod(helper,instanceMethod,instanceStr,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    env-&gt;DeleteLocalRef(class_helper);</span><br><span class="line">    env-&gt;DeleteLocalRef(staticStr);</span><br><span class="line">    env-&gt;DeleteLocalRef(instanceStr);</span><br><span class="line">    env-&gt;DeleteLocalRef(helper);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> env-&gt;NewStringUTF(<span class="string">"dds"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用javap来获取反射方法时的签名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -s com.dds.anyndk.JavaHelper</span><br></pre></td></tr></table></figure><h3 id="2-反射修改变量"><a href="#2-反射修改变量" class="headerlink" title="2. 反射修改变量"></a>2. 反射修改变量</h3><p>需要反射的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaHelper</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">     <span class="keyword">static</span> String b = <span class="string">"java字符串"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReflect</span><span class="params">(JavaHelper javaHelper)</span> </span>&#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"修改前 ： a = "</span> + a + <span class="string">" b="</span> + b);</span><br><span class="line">        AnyNdk.native11_4(javaHelper);</span><br><span class="line">        Log.e(TAG, <span class="string">"修改后 ： a = "</span> + a + <span class="string">" b="</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反射</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LOG_TAG    <span class="meta-string">"dds_native4"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LOGD(...)  __android_log_print(ANDROID_LOG_DEBUG,  LOG_TAG, __VA_ARGS__ )</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_dds_anyndk_AnyNdk_native11_14(JNIEnv *env, jclass type, jobject javaHelper) &#123;</span><br><span class="line"></span><br><span class="line">    jclass clazz = env-&gt;GetObjectClass(javaHelper);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得int a的标示</span></span><br><span class="line">    jfieldID a = env-&gt;GetFieldID(clazz, <span class="string">"a"</span>, <span class="string">"I"</span>);</span><br><span class="line"><span class="comment">// 获取a的值</span></span><br><span class="line">    <span class="keyword">int</span> value = env-&gt;GetIntField(javaHelper, a);</span><br><span class="line">    LOGD(<span class="string">"获得java属性a:%d"</span>, value);</span><br><span class="line"></span><br><span class="line">    env-&gt;SetIntField(javaHelper, a, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取String b 的标示</span></span><br><span class="line">    jfieldID b = env-&gt;GetStaticFieldID(clazz, <span class="string">"b"</span>, <span class="string">"Ljava.lang.String;"</span>);</span><br><span class="line">    <span class="comment">// 获取静态变量的值</span></span><br><span class="line">    <span class="keyword">auto</span> bStr = jstring(env-&gt;GetStaticObjectField(clazz, b));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *bc_str = env-&gt;GetStringUTFChars(bStr, JNI_FALSE);</span><br><span class="line">    LOGD(<span class="string">"获得java属性b:%s"</span>, bc_str);</span><br><span class="line"></span><br><span class="line">    jstring new_str = env-&gt;NewStringUTF(<span class="string">"C++字符串"</span>);</span><br><span class="line">    env-&gt;SetStaticObjectField(clazz, b, new_str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    env-&gt;ReleaseStringUTFChars(bStr, bc_str);</span><br><span class="line">    env-&gt;DeleteLocalRef(new_str);</span><br><span class="line">    env-&gt;DeleteLocalRef(clazz);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、JNI-OnLoad"><a href="#四、JNI-OnLoad" class="headerlink" title="四、JNI_OnLoad"></a>四、JNI_OnLoad</h2><p>调用System.loadLibrary()函数时， 内部就会去查找so中的 JNI_OnLoad 函数，如果存在此函数则调用。</p><p>JNI_OnLoad会：</p><p>告诉 VM 此 native 组件使用的 JNI 版本。</p><p>对应了Java版本，android中只支持JNI_VERSION_1_2 、JNI_VERSION_1_4、JNI_VERSION_1_6 </p><p>在JDK1.8有 JNI_VERSION_1_8。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">jint <span class="title">JNI_OnLoad</span><span class="params">(JavaVM* vm, <span class="keyword">void</span>* reserved)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 2、4、6都可以</span></span><br><span class="line">    <span class="keyword">return</span> JNI_VERSION_1_4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动态注册"><a href="#动态注册" class="headerlink" title="动态注册"></a>动态注册</h4><p>在此之前我们一直在jni中使用的 Java_PACKAGENAME_CLASSNAME_METHODNAME 来进行与java方法的匹配，这种方式我们称之为静态注册。</p><p>而动态注册则意味着方法名可以不用这么长了，在android aosp源码中就大量的使用了动态注册的形式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//Java：</span></span><br><span class="line"><span class="function">native <span class="keyword">void</span> <span class="title">dynamicNative</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">native String <span class="title">dynamicNative</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">dynamicNative1</span><span class="params">(JNIEnv *env, jobject jobj)</span></span>&#123;</span><br><span class="line">    LOGE(<span class="string">"dynamicNative1 动态注册"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">jstring  <span class="title">dynamicNative2</span><span class="params">(JNIEnv *env, jobject jobj,jint i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> env-&gt;NewStringUTF(<span class="string">"我是动态注册的dynamicNative2方法"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要动态注册的方法数组</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> JNINativeMethod mMethods[] = &#123;</span><br><span class="line">        &#123;<span class="string">"dynamicNative"</span>,<span class="string">"()V"</span>, (<span class="keyword">void</span> *)dynamicNative1&#125;,</span><br><span class="line">        &#123;<span class="string">"dynamicNative"</span>, <span class="string">"(I)Ljava/lang/String;"</span>, (jstring *)dynamicNative2&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//需要动态注册native方法的类名</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* mClassName = <span class="string">"com/dds/anyndk/AnyNdk"</span>;</span><br><span class="line"><span class="function">jint <span class="title">JNI_OnLoad</span><span class="params">(JavaVM *vm, <span class="keyword">void</span> *reserved)</span> </span>&#123;</span><br><span class="line">    JNIEnv *env = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//获得 JniEnv</span></span><br><span class="line">    <span class="keyword">int</span> r = vm-&gt;GetEnv((<span class="keyword">void</span> **) &amp;env, JNI_VERSION_1_4);</span><br><span class="line">    <span class="keyword">if</span> (r != JNI_OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    jclass activityCls = env-&gt;FindClass(mClassName);</span><br><span class="line">    <span class="comment">// 注册 如果小于0则注册失败</span></span><br><span class="line">    r = env-&gt;RegisterNatives(activityCls, mMethods, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (r != JNI_OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> JNI_VERSION_1_4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、c-线程中调用Java"><a href="#五、c-线程中调用Java" class="headerlink" title="五、c++线程中调用Java"></a>五、c++线程中调用Java</h2><p>native调用java需要使用JNIEnv这个结构体，而JNIEnv是由Jvm传入与线程相关的变量。</p><p>但是可以通过JavaVM的AttachCurrentThread方法来获取到当前线程中的JNIEnv指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">JavaVM* _vm = <span class="number">0</span>;</span><br><span class="line">jobject  _instance = <span class="number">0</span>;</span><br><span class="line"><span class="function">jint <span class="title">JNI_OnLoad</span><span class="params">(JavaVM* vm, <span class="keyword">void</span>* reserved)</span></span>&#123;</span><br><span class="line">    _vm = vm;</span><br><span class="line">    <span class="keyword">return</span> JNI_VERSION_1_4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">task</span><span class="params">(<span class="keyword">void</span> *args)</span> </span>&#123;</span><br><span class="line">    JNIEnv *env;</span><br><span class="line">    _vm-&gt;AttachCurrentThread(&amp;env, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    jclass clazz = env-&gt;GetObjectClass(_instance);</span><br><span class="line">    jmethodID methodId = env-&gt;GetStaticMethodID(clazz, <span class="string">"staticMethod"</span>, <span class="string">"(Ljava/lang/String;IZ)V"</span>);</span><br><span class="line">    jstring staticStr = env-&gt;NewStringUTF(<span class="string">"C++调用静态方法"</span>);</span><br><span class="line">    env-&gt;CallStaticVoidMethod(clazz, methodId, staticStr, <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">    env-&gt;DeleteLocalRef(clazz);</span><br><span class="line">    env-&gt;DeleteLocalRef(staticStr);</span><br><span class="line"></span><br><span class="line">    _vm-&gt;DetachCurrentThread();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_dds_anyndk_AnyNdk_native11_15(JNIEnv *env, jclass type, jobject javaHelper) &#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> pid;</span><br><span class="line">    _instance = env-&gt;NewGlobalRef(javaHelper);</span><br><span class="line">    <span class="comment">// 开启线程</span></span><br><span class="line">    pthread_create(&amp;pid, <span class="number">0</span>, task, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://github.com/ddssingsong/AnyNdk" target="_blank" rel="noopener">https://github.com/ddssingsong/AnyNdk</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> NDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【NDK系列9】c++ 智能指针</title>
      <link href="/android/ndk/ndk-9/"/>
      <url>/android/ndk/ndk-9/</url>
      
        <content type="html"><![CDATA[<p>自C++11起，C++标准库提供了两大类型的智能指针</p><a id="more"></a><h2 id="1-shared-ptr"><a href="#1-shared-ptr" class="headerlink" title="1. shared_ptr"></a>1. shared_ptr</h2><p>操作引用计数实现共享式拥有的概念。多个智能指针可以指向相同的对象，这个对象和其相关资源会在最后一个被销毁时释放。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">~A() &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"释放A"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//自动释放 引用计数为1</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;A&gt; a(<span class="keyword">new</span> A());</span><br><span class="line">    <span class="comment">//退出方法 shared_ptr a本身释放，对内部的 A 对象引用计数减1 则为0 释放new 出来的A 对象 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然使用shared_ptr能够非常方便的为我们自动释放对象，但是还是会出现一些问题。最典型的就是循环引用问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">~A() &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"释放A"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;B&gt; b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">~B() &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"释放B"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;A&gt; a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//自动释放</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;A&gt; a(<span class="keyword">new</span> A()); <span class="comment">//A引用计数为1</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;B&gt; b(<span class="keyword">new</span> B()); <span class="comment">//B引用计数为1</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.use_count() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//查看内部对象引用计数</span></span><br><span class="line">a-&gt;b = b;<span class="comment">//A 引用计数为2</span></span><br><span class="line">b-&gt;a = a;<span class="comment">//B 引用计数为2</span></span><br><span class="line"><span class="comment">//退出方法，a释放，A引用计数-1结果为1 不会释放 B也一样</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-weak-ptr"><a href="#2-weak-ptr" class="headerlink" title="2. weak_ptr"></a>2. weak_ptr</h2><p>weak_ptr是为配合shared_ptr而引入的一种智能指针。主要用于观测资源的引用情况。</p><p>它的构造和析构不会引起引用记数的增加或减少。没有重载*和-&gt;但可以使用lock获得一个可用的shared_ptr对象。</p><p>weak_ptr 提供expired 方法等价于 use_count == 0，当expired为true时，lock返回一个存储空指针的shared_ptr </p><p>配合shared_ptr解决循环引用问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">~A() &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"释放A"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">weak_ptr&lt;B&gt; b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">~B() &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"释放B"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">weak_ptr&lt;A&gt; a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//自动释放</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;A&gt; a(<span class="keyword">new</span> A()); <span class="comment">//A引用计数为1</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;B&gt; b(<span class="keyword">new</span> B()); <span class="comment">//B引用计数为1</span></span><br><span class="line"></span><br><span class="line">a-&gt;b = b;<span class="comment">//weak_ptr 引用计数不增加</span></span><br><span class="line">b-&gt;a = a;<span class="comment">//weak_ptr 引用计数不增加</span></span><br><span class="line"><span class="comment">//退出方法，A B释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-unique-ptr"><a href="#3-unique-ptr" class="headerlink" title="3. unique_ptr"></a>3. unique_ptr</h2><p>实现独占式引用，保证同一时间只有一个智能指针指向内部对象。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;A&gt; a(<span class="keyword">new</span> A());</span><br></pre></td></tr></table></figure><h2 id="4-自定义智能指针"><a href="#4-自定义智能指针" class="headerlink" title="4. 自定义智能指针"></a>4. 自定义智能指针</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ptr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Ptr() &#123;</span><br><span class="line">count = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>);</span><br><span class="line">t = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Ptr(T *t):t(t) &#123;</span><br><span class="line"><span class="comment">//引用计数为1</span></span><br><span class="line">count = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">~Ptr() &#123;</span><br><span class="line"><span class="comment">//引用计数-1 为0表示可以释放T了</span></span><br><span class="line"><span class="keyword">if</span> (--(*count) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (t) &#123;</span><br><span class="line"><span class="keyword">delete</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> count;</span><br><span class="line">t = <span class="number">0</span>;</span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝构造函数</span></span><br><span class="line">Ptr(<span class="keyword">const</span> Ptr&lt;T&gt; &amp;p) &#123;</span><br><span class="line"><span class="comment">//引用计数+1</span></span><br><span class="line">++(*p.count);</span><br><span class="line">t = p.t;</span><br><span class="line">count = p.count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Ptr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Ptr&lt;T&gt;&amp; p) &#123;</span><br><span class="line">++(*p.count);</span><br><span class="line"><span class="comment">//检查老的数据是否需要删除</span></span><br><span class="line"><span class="keyword">if</span> (--(*count) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (t) &#123;</span><br><span class="line"><span class="keyword">delete</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> count;</span><br><span class="line">&#125;</span><br><span class="line">t = p.t;</span><br><span class="line">count = p.count;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载-&gt; 操作T 类</span></span><br><span class="line">T* <span class="keyword">operator</span>-&gt;() &#123; <span class="keyword">return</span> t; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T *t;</span><br><span class="line"><span class="keyword">int</span> *count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> NDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【NDK系列8】c++ 线程基本使用 线程同步</title>
      <link href="/android/ndk/ndk-8/"/>
      <url>/android/ndk/ndk-8/</url>
      
        <content type="html"><![CDATA[<p>线程，有时被称为轻量进程，是程序执行的最小单元。 </p><a id="more"></a><h2 id="一、C-11线程"><a href="#一、C-11线程" class="headerlink" title="一、C++11线程"></a>一、C++11线程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"task:"</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">thread <span class="title">t1</span><span class="params">(task,<span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="comment">//等待线程结束再继续执行</span></span><br><span class="line">t1.join();</span><br></pre></td></tr></table></figure><h2 id="二、POSIX线程"><a href="#二、POSIX线程" class="headerlink" title="二、POSIX线程"></a>二、POSIX线程</h2><p>POSIX 可移植操作系统接口，标准定义了操作系统应该为应用程序提供的接口标准 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">pthreadTask</span><span class="params">(<span class="keyword">void</span>* args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>* i = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>*&gt;(args);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"posix线程:"</span> &lt;&lt; *i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pthread_t</span> pid;</span><br><span class="line"><span class="keyword">int</span> pi = <span class="number">100</span>;</span><br><span class="line">pthread_create(&amp;pid, <span class="number">0</span>, pthreadTask, &amp;pi);</span><br><span class="line"><span class="comment">//等待线程的结束</span></span><br><span class="line">pthread_join(pid,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h3 id="1-线程属性"><a href="#1-线程属性" class="headerlink" title="1. 线程属性"></a>1. 线程属性</h3><p>线程具有属性，用 <code>pthread_attr_t</code> 表示 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line"><span class="comment">//初始化 attr中为操作系统实现支持的线程所有属性的默认值</span></span><br><span class="line">pthread_attr_init(&amp;attr);</span><br><span class="line">pthread_attr_destroy(&amp;attr);</span><br></pre></td></tr></table></figure><h4 id="分离线程"><a href="#分离线程" class="headerlink" title="分离线程"></a>分离线程</h4><p>线程创建默认是非分离的，当<code>pthread_join()</code>函数返回时，创建的线程终止，释放自己占用的系统资源</p><p>分离线程不能被其他线程等待,<code>pthread_join()</code>无效，线程自己玩自己的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置是否为分离线程</span></span><br><span class="line"><span class="comment">//PTHREAD_CREATE_DETACHED 分离</span></span><br><span class="line"><span class="comment">//PTHREAD_CREATE_JOINABLE 非分离</span></span><br><span class="line">pthread_attr_setdetachstate(&amp;attr,PTHREAD_CREATE_DETACHED);</span><br></pre></td></tr></table></figure><h4 id="调度策略与优先级"><a href="#调度策略与优先级" class="headerlink" title="调度策略与优先级"></a>调度策略与优先级</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置调度策略 </span></span><br><span class="line"><span class="comment">//返回0 设置成功</span></span><br><span class="line">pthread_attr_setschedpolicy(&amp;attr, SCHED_FIFO);</span><br><span class="line"><span class="comment">// SCHED_FIFO </span></span><br><span class="line"><span class="comment">//实时调度策略，先到先服务 一旦占用cpu则一直运行。一直运行直到有更高优先级任务到达或自己放弃。</span></span><br><span class="line"><span class="comment">// SCHED_RR</span></span><br><span class="line"><span class="comment">//实时调度策略，时间轮转 系统分配一个时间段，在时间段内执行本线程</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置优先级</span></span><br><span class="line"><span class="comment">//获得对应策略的最小、最大优先级</span></span><br><span class="line"><span class="keyword">int</span> max = sched_get_priority_max(SCHED_FIFO);</span><br><span class="line"><span class="keyword">int</span> min = sched_get_priority_min(SCHED_FIFO);</span><br><span class="line">sched_param param;</span><br><span class="line">param.sched_priority = max;</span><br><span class="line">pthread_attr_setschedparam(&amp;attr, &amp;param);</span><br></pre></td></tr></table></figure><h3 id="1-线程同步"><a href="#1-线程同步" class="headerlink" title="1. 线程同步"></a>1. 线程同步</h3><p>多线程同时读写同一份共享资源的时候，可能会引起冲突。需要引入线程“同步”机制，即各位线程之间有序地对共享资源进行操作。</p><p>以下是会出现问题的写法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">pop</span><span class="params">(<span class="keyword">void</span>* args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 线程未同步导致的多线程安全问题</span></span><br><span class="line">    <span class="comment">// 会有重复的数据取出并出现异常</span></span><br><span class="line"><span class="keyword">if</span> (!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"取出数据:%d\n"</span>, q.front());</span><br><span class="line">q.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"无数据\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">q.push(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pthread_t</span> pid[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">pthread_create(&amp;pid[i], <span class="number">0</span>, pop, &amp;q);</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加入互斥锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">pop</span><span class="params">(<span class="keyword">void</span>* args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 锁</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"><span class="keyword">if</span> (!q.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"取出数据:%d\n"</span>, q.front());</span><br><span class="line">q.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"无数据\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 放</span></span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化互斥锁</span></span><br><span class="line">pthread_mutex_init(&amp;mutex, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">q.push(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pthread_t</span> pid[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">pthread_create(&amp;pid[i], <span class="number">0</span>, pop, &amp;q);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//需要释放</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">pthread_join(pid[i], <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-条件变量"><a href="#2-条件变量" class="headerlink" title="2. 条件变量"></a>2. 条件变量</h3><p>条件变量是线程间进行同步的一种机制，主要包括两个动作：一个线程等待”条件变量的条件成立”而挂起；另一个线程使”条件成立”,从而唤醒挂起线程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">SafeQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">SafeQueue() &#123;</span><br><span class="line">pthread_mutex_init(&amp;mutex,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">~SafeQueue() &#123;</span><br><span class="line">pthread_mutex_destory(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line">q.push(t);</span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dequeue</span><span class="params">(T&amp; t)</span> </span>&#123;</span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"><span class="keyword">if</span> (!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">t = q.front();</span><br><span class="line">q.pop();</span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">queue</span>&lt;T&gt; q;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的模板类存放数据T，并使用互斥锁保证对queue的操作是线程安全的。这就是一个生产/消费模式。</p><p>如果在取出数据的时候，queue为空，则一直等待，直到下一次enqueue加入数据。</p><p>这就是一个典型的生产/消费模式, 加入条件变量使 “dequeue”  挂起,直到由其他地方唤醒</p><p><strong>下面是使用条件变量实现</strong></p><p>通过使用cond条件来 唤醒等待中的线程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">SafeQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">SafeQueue() &#123;</span><br><span class="line">pthread_mutex_init(&amp;mutex,<span class="number">0</span>);</span><br><span class="line">pthread_cond_init(&amp;cond, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">~SafeQueue() &#123;</span><br><span class="line">pthread_mutex_destory(&amp;mutex);</span><br><span class="line">pthread_cond_destory(&amp;cond);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line">q.push(t);</span><br><span class="line"><span class="comment">//发出信号 通知挂起线程</span></span><br><span class="line"><span class="comment">//由系统唤醒一个线程</span></span><br><span class="line"><span class="comment">//pthread_cond_signal(&amp;cond);</span></span><br><span class="line"><span class="comment">// 广播 对应多个消费者的时候 多个线程等待唤醒所有</span></span><br><span class="line">pthread_cond_broadcast(&amp;cond);</span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dequeue</span><span class="params">(T&amp; t)</span> </span>&#123;</span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"><span class="comment">//可能被意外唤醒 所以while循环</span></span><br><span class="line"><span class="keyword">while</span> (q.empty())</span><br><span class="line">&#123;</span><br><span class="line">pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line">t = q.front();</span><br><span class="line">q.pop();</span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">queue</span>&lt;T&gt; q;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="keyword">pthread_cond_t</span> cond;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://github.com/ddssingsong/AnyNdk" target="_blank" rel="noopener">https://github.com/ddssingsong/AnyNdk</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> NDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【NDK系列7】c/c++ 文件与流操作</title>
      <link href="/android/ndk/ndk-7/"/>
      <url>/android/ndk/ndk-7/</url>
      
        <content type="html"><![CDATA[<p>这篇主要讲c/c++的文件读写操作</p><a id="more"></a><h3 id="一、C-语言的文件读写操作"><a href="#一、C-语言的文件读写操作" class="headerlink" title="一、C 语言的文件读写操作"></a>一、C 语言的文件读写操作</h3><p>头文件 : stdio.h</p><p>函数原型：<code>FILE * fopen(const char * path, const char * mode);</code></p><p>path:  操作的文件路径</p><p>mode:模式</p><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>r</td><td>打开一个已有的文本文件，允许读取文件。</td></tr><tr><td>w</td><td>打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会从文件的开头写入内容。如果文件存在，则该会被截断为零长度，重新写入。</td></tr><tr><td>a</td><td>打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会在已有的文件内容中追加内容。</td></tr><tr><td>r+</td><td>打开一个文本文件，允许读写文件。</td></tr><tr><td>w+</td><td>打开一个文本文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件。</td></tr><tr><td>a+</td><td>打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式。</td></tr></tbody></table><p><strong>写入</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FILE *f = fopen(<span class="string">"xxxx\\t.txt"</span>,<span class="string">"w"</span>);</span><br><span class="line"><span class="comment">//写入单个字符</span></span><br><span class="line">fputc(<span class="string">'a'</span>, f);</span><br><span class="line">fclose(f);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FILE *f = fopen(<span class="string">"xxxx\\t.txt"</span>,<span class="string">"w"</span>);</span><br><span class="line"><span class="keyword">char</span> *txt = <span class="string">"123456"</span>;</span><br><span class="line"><span class="comment">//写入以 null 结尾的字符数组</span></span><br><span class="line"><span class="built_in">fputs</span>(txt, f);</span><br><span class="line"><span class="comment">//格式化并输出</span></span><br><span class="line"><span class="built_in">fprintf</span>(f,<span class="string">"%s"</span>,txt);</span><br><span class="line">fclose(f);</span><br></pre></td></tr></table></figure><p><strong>读取</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buff[<span class="number">255</span>];</span><br><span class="line">FILE *f = fopen(<span class="string">"xxxx\\t.txt"</span>, <span class="string">"r"</span>);</span><br><span class="line"><span class="comment">//读取 遇到第一个空格字符停止</span></span><br><span class="line"><span class="built_in">fscanf</span>(f, <span class="string">"%s"</span>, buff);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"1: %s\n"</span>, buff);</span><br><span class="line"></span><br><span class="line"><span class="comment">//最大读取 255-1 个字符</span></span><br><span class="line">fgets(buff, <span class="number">255</span>, f);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"2: %s\n"</span>, buff);</span><br><span class="line">fclose(f);</span><br></pre></td></tr></table></figure><p><strong>二进制读写</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二进制 I/O 函数</span></span><br><span class="line"><span class="keyword">size_t</span> fread(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size_of_elements, </span><br><span class="line">             <span class="keyword">size_t</span> number_of_elements, FILE *a_file);       </span><br><span class="line"><span class="keyword">size_t</span> fwrite(<span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size_of_elements, </span><br><span class="line">             <span class="keyword">size_t</span> number_of_elements, FILE *a_file);</span><br><span class="line"><span class="comment">//1、写入/读取数据缓存区</span></span><br><span class="line"><span class="comment">//2、每个数据项的大小</span></span><br><span class="line"><span class="comment">//3、多少个数据项</span></span><br><span class="line"><span class="comment">//4、流</span></span><br><span class="line"><span class="comment">//如：图片、视频等以二进制操作:</span></span><br><span class="line"><span class="comment">//写入buffer 有 1024个字节</span></span><br><span class="line">fwrite(buffer,<span class="number">1024</span>,<span class="number">1</span>,f);</span><br></pre></td></tr></table></figure><h3 id="二、C-文件读写操作"><a href="#二、C-文件读写操作" class="headerlink" title="二、C++ 文件读写操作"></a>二、C++ 文件读写操作</h3><p><code>&lt;iostream\&gt;</code> 和 <code>\&lt;fstream\&gt;</code></p><table><thead><tr><th>数据类型</th><th>描述</th></tr></thead><tbody><tr><td>ofstream</td><td>输出文件流，创建文件并向文件写入信息。</td></tr><tr><td>ifstream</td><td>输入文件流，从文件读取信息。</td></tr><tr><td>fstream</td><td>文件流，且同时具有 ofstream 和 ifstream 两种功能。</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> data[<span class="number">100</span>];</span><br><span class="line"><span class="comment">// 以写模式打开文件</span></span><br><span class="line">ofstream outfile;</span><br><span class="line">outfile.open(<span class="string">"XXX\\f.txt"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入你的名字: "</span>;</span><br><span class="line"><span class="comment">//cin 接收终端的输入</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; data;</span><br><span class="line"><span class="comment">// 向文件写入用户输入的数据</span></span><br><span class="line">outfile &lt;&lt; data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// 关闭打开的文件</span></span><br><span class="line">outfile.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以读模式打开文件</span></span><br><span class="line">ifstream infile;</span><br><span class="line">infile.open(<span class="string">"XXX\\f.txt"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"读取文件"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">infile &gt;&gt; data;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭</span></span><br><span class="line">infile.close();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> NDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【NDK系列6】C++ 容器</title>
      <link href="/android/ndk/ndk-6/"/>
      <url>/android/ndk/ndk-6/</url>
      
        <content type="html"><![CDATA[<p>容器，就是用来存放东西的盒子。</p><p>常用的容器包括：数组array,  链表list，  树tree，  栈stack，  队列queue，  散列表hash table,  集合set、映射表map 等等。容器便是容纳这些数据结构的。这些数据结构分为序列式与关联式两种，容器也分为<strong>序列式容器</strong>和<strong>关联式容器</strong>。</p><a id="more"></a><p>STL 标准模板库，核心包括容器、算法、迭代器。</p><p>元素排列次序与元素无关，由元素添加到容器的顺序决定</p><h3 id="一、序列式容器-顺序容器"><a href="#一、序列式容器-顺序容器" class="headerlink" title="一、序列式容器/顺序容器"></a>一、序列式容器/顺序容器</h3><table><thead><tr><th>容器</th><th>说明</th></tr></thead><tbody><tr><td>vector</td><td>支持快速随机访问</td></tr><tr><td>list</td><td>支持快速插入、删除</td></tr><tr><td>deque</td><td>双端队列  允许两端都可以进行入队和出队操作的队列</td></tr><tr><td>stack</td><td>后进先出LIFO(Last In First Out)堆栈</td></tr><tr><td>queue</td><td>先进先出FIFO(First Input First Output)队列</td></tr><tr><td>priority_queue</td><td>有优先级管理的queue</td></tr></tbody></table><h4 id="1-向量-vector"><a href="#1-向量-vector" class="headerlink" title="1. 向量(vector)"></a>1. 向量(vector)</h4><blockquote><p>连续存储的元素 </p></blockquote><p><strong>迭代器</strong>的实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得指向首元素的迭代器  模板类，不是指针，当做指针来使用</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = vec.begin();</span><br><span class="line"><span class="comment">//遍历元素</span></span><br><span class="line"><span class="keyword">for</span> (; it &lt; vec.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//begin和end   分别获得 指向容器第一个元素和最后一个元素下一个位置的迭代器</span></span><br><span class="line"><span class="comment">//rbegin和rend 分别获得 指向容器最后一个元素和第一个元素前一个位置的迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意循环中操作元素对迭代器的影响</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = vec.begin();</span><br><span class="line"><span class="keyword">for</span> (; it &lt; vec.end(); )&#123;</span><br><span class="line">    <span class="comment">//删除值为2的元素 </span></span><br><span class="line"><span class="keyword">if</span> (*it == <span class="number">2</span>) &#123;</span><br><span class="line">vec.erase(it);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">it++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-列表-list"><a href="#2-列表-list" class="headerlink" title="2. 列表 (list)"></a>2. 列表 (list)</h4><blockquote><p>由节点组成的双向链表，每个结点包含着一个元素  </p></blockquote><h4 id="3-双端队列-deque"><a href="#3-双端队列-deque" class="headerlink" title="3. 双端队列(deque)"></a>3. 双端队列(deque)</h4><blockquote><p>连续存储的指向不同元素的指针所组成的数组 </p></blockquote><h4 id="4-栈-stack"><a href="#4-栈-stack" class="headerlink" title="4. 栈(stack)"></a>4. 栈(stack)</h4><blockquote><p>后进先出的值的排列 </p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line">s.push(<span class="number">1</span>);</span><br><span class="line">s.push(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//弹栈</span></span><br><span class="line">s.pop();</span><br><span class="line"><span class="comment">//栈顶</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s.top() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h4 id="5-队列-queue"><a href="#5-队列-queue" class="headerlink" title="5. 队列(queue)"></a>5. 队列(queue)</h4><blockquote><p>先进先出的值的排列 </p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.push(<span class="number">1</span>);</span><br><span class="line">q.push(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//移除最后一个</span></span><br><span class="line">q.pop();</span><br><span class="line"><span class="comment">//获得第一个</span></span><br><span class="line">q.front();</span><br><span class="line"><span class="comment">//最后一个元素</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; q.back() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h4 id="6-优先队列-priority-queue"><a href="#6-优先队列-priority-queue" class="headerlink" title="6. 优先队列(priority_queue )"></a>6. 优先队列(priority_queue )</h4><blockquote><p>元素的次序是由所存储的数据的某个值排列的一种队列 </p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最大的在队首</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="comment">//在vector之上实现的</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt; &gt;; </span><br><span class="line"><span class="comment">//vector 承载底层数据结构堆的容器</span></span><br><span class="line"><span class="comment">//less 表示数字大的优先级高，而 greater 表示数字小的优先级高</span></span><br><span class="line"><span class="comment">//less   让优先队列总是把最大的元素放在队首</span></span><br><span class="line"><span class="comment">//greater    让优先队列总是把最小的元素放在队首</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//less和greater都是一个模板结构体 也可以自定义</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> grade;</span><br><span class="line">Student(<span class="keyword">int</span> grade):grade(grade) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(Student* s1, Student* s2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// &gt; 从小到大</span></span><br><span class="line">        <span class="comment">// &lt; 从大到小 </span></span><br><span class="line"><span class="keyword">return</span> s1-&gt;grade &gt; s2-&gt;grade;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(Student s1, Student s2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> s1.grade &gt; s2.grade;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;Student*, <span class="built_in">vector</span>&lt;Student*&gt;, cmp &gt; q1;</span><br><span class="line">q1.push(<span class="keyword">new</span> Student(<span class="number">2</span>));</span><br><span class="line">q1.push(<span class="keyword">new</span> Student(<span class="number">1</span>));</span><br><span class="line">q1.push(<span class="keyword">new</span> Student(<span class="number">3</span>));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; q1.top()-&gt;grade &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h3 id="二、关联式容器"><a href="#二、关联式容器" class="headerlink" title="二、关联式容器"></a>二、关联式容器</h3><blockquote><p>关联容器和大部分顺序容器操作一致</p><p>关联容器中的元素是按关键字来保存和访问的 支持高效的关键字查找与访问</p></blockquote><h4 id="1-集合-set"><a href="#1-集合-set" class="headerlink" title="1. 集合(set)"></a>1. 集合(set)</h4><blockquote><p>由节点组成的红黑树，每个节点都包含着一个元素,元素不可重复</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; a;  </span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; a1=&#123;<span class="string">"fengxin"</span>,<span class="string">"666"</span>&#125;;</span><br><span class="line">a.insert(<span class="string">"fengxin"</span>);  <span class="comment">// 插入一个元素</span></span><br><span class="line">a.erase(<span class="string">"123"</span>);<span class="comment">//删除</span></span><br></pre></td></tr></table></figure><h4 id="2-键值对-map"><a href="#2-键值对-map" class="headerlink" title="2. 键值对(map)"></a>2. 键值对(map)</h4><blockquote><p>由{键，值}对组成的集合</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; m;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; m1 = &#123; &#123; <span class="number">1</span>,<span class="string">"dds"</span> &#125;,&#123; <span class="number">2</span>,<span class="string">"dds"</span> &#125; &#125;;</span><br><span class="line"><span class="comment">//插入元素</span></span><br><span class="line">m1.insert(&#123; <span class="number">3</span>,<span class="string">"ddss"</span> &#125;);</span><br><span class="line"><span class="comment">//pair=键值对</span></span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; p(<span class="number">4</span>, <span class="string">"ddsd"</span>);</span><br><span class="line">m1.insert(p);</span><br><span class="line"><span class="comment">//insetrt 返回 map&lt;int, string&gt;::iterator : bool 键值对</span></span><br><span class="line"><span class="comment">//如果 插入已经存在的 key，则会插入失败   </span></span><br><span class="line"><span class="comment">//multimap：允许重复key</span></span><br><span class="line"><span class="comment">//使用m1[3] = "xx" 能够覆盖</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过【key】操作元素</span></span><br><span class="line">m1[<span class="number">5</span>] = <span class="string">"yihan"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; m1[<span class="number">5</span>].c_str() &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"><span class="comment">//通过key查找元素</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator it = m1.find(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (*it).second.c_str()&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// 删除 </span></span><br><span class="line">m1.erase(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">for</span> (it = m1.begin(); it != m1.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; item = *it;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; item.first &lt;&lt; <span class="string">":"</span> &lt;&lt; item.second.c_str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unordered_map</p><p> c++11取代hash_map（哈希表实现，无序）</p><p>哈希表实现查找速度会比RB树实现快,但rb整体更节省内存</p><p>需要无序容器，高频快速查找删除，数据量较大用unordered_map；</p><p>需要有序容器，查找删除频率稳定，在意内存时用map。</p><h4 id="3-红黑树"><a href="#3-红黑树" class="headerlink" title="3. 红黑树"></a>3. 红黑树</h4><p>红黑树(Red Black Tree)又称为 RB树,是一种相对平衡二叉树 。</p><blockquote><p>1.节点是红色或黑色。</p><p>2.根节点是黑色。</p><p>3.每个叶子节点(空节点)都是黑色的。</p><p>4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</p><p>5.从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20190626161810620.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTEwNzcwMjc=,size_16,color_FFFFFF,t_70" alt="1、插入7"></p><blockquote><ol><li>插入新节点总是红色节点</li><li>如果插入节点的父节点是黑色, 能维持性质</li><li>如果插入节点的父节点是红色, 破坏了性质。插入算法就是通过重新着色或旋转, 来维持性质</li></ol></blockquote><blockquote><p>插入 7 后,破坏了规则，那么需要根据不同的状况进行不同的策略使其平衡并符合规则。</p><p>7的父节点8 与叔父节点 12 都是红色，则我们可以将8、12两个重绘为黑色并重绘祖父节点9为红色。</p><p>这里9是根节点，为了满足规则1，又把它重绘为黑色 .</p><p>经过调整：</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20190626161743148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTEwNzcwMjc=,size_16,color_FFFFFF,t_70" alt="1、插入7"></p><blockquote><p>现在满足5个规则，因此7插入完成。</p><p>接下来插入 6</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20190626161829356.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTEwNzcwMjc=,size_16,color_FFFFFF,t_70" alt="插入6"></p><blockquote><p>现在新节点 6 是 父节点 7的左节点，而6的叔父节点 缺少，父节点 7 又是祖父节点8的左子节点 ，</p><p>这种情形下，我们进行针对6节点的祖父节点8的一次右旋转</p><p>右旋转：</p><p>顺时针旋转红黑树的两个节点，使得父节点被自己的左孩子取代，而自己成为自己的右孩子。</p><p>左旋转则倒过来</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20190626161844399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTEwNzcwMjc=,size_16,color_FFFFFF,t_70" alt="插入6右旋"></p><blockquote><p>再切换 7 和 8 的颜色</p></blockquote><p><img src="https://img-blog.csdnimg.cn/2019062616185649.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTEwNzcwMjc=,size_16,color_FFFFFF,t_70" alt="插入6旋转切换颜色"></p><blockquote><p>再插入5，5和6都是红色，将 父节点 6 和叔父节点 8 绘为黑色，祖父7设为红色，最终</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20190626161905154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTEwNzcwMjc=,size_16,color_FFFFFF,t_70" alt="最终插入5"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> NDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【NDK系列5】c++ 面向对象编程</title>
      <link href="/android/ndk/ndk-5/"/>
      <url>/android/ndk/ndk-5/</url>
      
        <content type="html"><![CDATA[<p>关于java的面向对象，我们能说出花来，这篇主要讲c++的面向对象</p><h2 id="一-类"><a href="#一-类" class="headerlink" title="一. 类"></a>一. 类</h2><p>C++ 在 C 语言的基础上增加了面向对象编程，C++ 支持面向对象程序设计。类是 C++ 的核心特性，用户定义的类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> i;    <span class="comment">//默认 private</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Student(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> k):i(i),j(j),k(k)&#123;&#125;;<span class="comment">//构造方法 </span></span><br><span class="line">~Student()&#123;&#125;;<span class="comment">//析构方法 </span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>调用方法</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用构造方法 栈</span></span><br><span class="line"><span class="comment">//出方法释放student 调用析构方法</span></span><br><span class="line"><span class="function">Student <span class="title">student</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//动态内存(堆)</span></span><br><span class="line">Student *student = <span class="keyword">new</span> Student(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放</span></span><br><span class="line"><span class="keyword">delete</span> student;</span><br><span class="line">student = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="二-常量函数"><a href="#二-常量函数" class="headerlink" title="二. 常量函数"></a>二. 常量函数</h2><h2 id="三-友元"><a href="#三-友元" class="headerlink" title="三. 友元"></a>三. 友元</h2><h2 id="四-静态成员"><a href="#四-静态成员" class="headerlink" title="四. 静态成员"></a>四. 静态成员</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Instance.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Instance</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Instance* <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printHello</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Instance *instance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Instance.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Instance.h"</span></span></span><br><span class="line">Instance* Instance::instance = <span class="number">0</span>;</span><br><span class="line">Instance* Instance::getInstance() &#123;</span><br><span class="line"><span class="comment">//C++11以后，编译器保证内部静态变量的线程安全性</span></span><br><span class="line"><span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">instance = <span class="keyword">new</span> Instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五-重载函数"><a href="#五-重载函数" class="headerlink" title="五. 重载函数"></a>五. 重载函数</h2><h2 id="六-继承"><a href="#六-继承" class="headerlink" title="六. 继承"></a>六. 继承</h2><h2 id="七-多态"><a href="#七-多态" class="headerlink" title="七. 多态"></a>七. 多态</h2><p>多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。</p><p>静态多态（静态联编）是指在编译期间就可以确定函数的调用地址，通过<strong>函数重载</strong>和<strong>模版（泛型编程）</strong>实现 </p><p>动态多态（动态联编）是指函数调用的地址不能在编译器期间确定，必须需要在运行时才确定 ,通过<strong>继承+虚函数</strong> 实现</p><h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><p>### </p><h2 id="八-模板"><a href="#八-模板" class="headerlink" title="八. 模板"></a>八. 模板</h2><p>模板是泛型编程的基础</p><h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><h3 id="类模板-泛型类"><a href="#类模板-泛型类" class="headerlink" title="类模板(泛型类)"></a>类模板(泛型类)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>,<span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">T <span class="title">add</span><span class="params">(E e,T t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> e+t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Queue&lt;<span class="keyword">int</span>,<span class="keyword">float</span>&gt; q;</span><br><span class="line">q.add(<span class="number">1</span>,<span class="number">1.1f</span>) = <span class="number">2.1f</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://github.com/ddssingsong/AnyNdk" target="_blank" rel="noopener">https://github.com/ddssingsong/AnyNdk</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> NDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【NDK系列4】c++  字符串、c兼容、引用、命名空间</title>
      <link href="/android/ndk/ndk-4/"/>
      <url>/android/ndk/ndk-4/</url>
      
        <content type="html"><![CDATA[<p>终于开始c++基础的整理了，本节介绍c++基础内容</p><a id="more"></a><h2 id="一、输出"><a href="#一、输出" class="headerlink" title="一、输出"></a>一、输出</h2><p>C使用printf向终端输出信息，C++提供了 标准输出流 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. c++输出</span></span><br><span class="line"><span class="keyword">int</span> time = <span class="number">8</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"dds:"</span> &lt;&lt; time &lt;&lt; <span class="string">"点,"</span> &lt;&lt; <span class="string">"hello world"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h2 id="二、函数符号兼容"><a href="#二、函数符号兼容" class="headerlink" title="二、函数符号兼容"></a>二、函数符号兼容</h2><p>C的大部分代码可以在C++中直接使用，但是仍然有需要注意的地方。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果需要在C++中调用C实现的库中的方法  extern</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指示编译器这部分代码使用C的方式进行编译而不是C++</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br></pre></td></tr></table></figure><p>对于 <code>func</code> 函数 被C的编译器编译后在函数库中的名字可能为<code>func</code>(无参数符号)，而C++编译器则会产生类似<code>funcii</code>之类的名字。</p><p>因此，对于C库可以</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus    </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//__cplusplus 是由c++编译器定义的宏，用于表示当前处于c++环境</span></span><br></pre></td></tr></table></figure><h2 id="三、引用"><a href="#三、引用" class="headerlink" title="三、引用"></a>三、引用</h2><p>引用是C++定义的一种新类型，引用和指针是两个东西，这里需要分清楚</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明形参为引用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span>&amp; i)</span> </span>&#123;</span><br><span class="line">i = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">change(i);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i); <span class="comment">//i == 10</span></span><br></pre></td></tr></table></figure><h2 id="四、字符串"><a href="#四、字符串" class="headerlink" title="四、字符串"></a>四、字符串</h2><p>字符串实际上是使用 NULL字符 <code>&#39;\0&#39;</code>终止的一维字符数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符数组 = 字符串</span></span><br><span class="line"><span class="keyword">char</span> str1[<span class="number">6</span>] = &#123;<span class="string">'H'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>, <span class="string">'\0'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自动加入\0</span></span><br><span class="line"><span class="keyword">char</span> str2[] = <span class="string">"Hello"</span>;</span><br></pre></td></tr></table></figure><h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>strcpy(s1, s2);</td><td>复制字符串 s2 到字符串 s1。</td></tr><tr><td>strcat(s1, s2);</td><td>连接字符串 s2 到字符串 s1 的末尾。</td></tr><tr><td>strlen(s1);</td><td>返回字符串 s1 的长度。</td></tr><tr><td>strcmp(s1, s2);</td><td>如果 s1 和 s2 相同，则返回 0；如果 s1 &lt; s2 则返回小于0；如果 s1&gt;s2 则返回大于0</td></tr><tr><td>strchr(s1, ch);</td><td>返回指向字符串 s1 中字符 ch 的第一次出现的位置的指针。</td></tr><tr><td>strstr(s1, s2);</td><td>返回指向字符串 s1 中字符串 s2 的第一次出现的位置的指针。</td></tr></tbody></table><h3 id="C-string类"><a href="#C-string类" class="headerlink" title="C++ string类"></a>C++ string类</h3><p>C++ 标准库提供了 <strong>string</strong> 类类型，支持上述所有的操作，另外还增加了其他更多的功能。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//string 定义在 std命令空间中</span></span><br><span class="line">usning <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str1 = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="built_in">string</span> str2 = <span class="string">"World"</span>;</span><br><span class="line"></span><br><span class="line">str1.append(str2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得c 风格字符串</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *s1 = str1.c_str();</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串长度</span></span><br><span class="line">str1.size();</span><br><span class="line"></span><br><span class="line"><span class="comment">//长度是否为0</span></span><br><span class="line">str1.empty();</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure><h2 id="五-命名空间"><a href="#五-命名空间" class="headerlink" title="五. 命名空间"></a>五. 命名空间</h2><p>namespace 命名空间 相当于package</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">错误 : a();</span><br><span class="line"><span class="comment">// :: 域操作符</span></span><br><span class="line">正确： A::a();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//当然也能够嵌套</span></span><br><span class="line"><span class="keyword">namespace</span> A &#123;</span><br><span class="line"><span class="keyword">namespace</span> B&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">A::B::a();</span><br><span class="line"></span><br><span class="line"><span class="comment">//还能够使用using 关键字</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> A;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> A::B;</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://github.com/ddssingsong/AnyNdk" target="_blank" rel="noopener">https://github.com/ddssingsong/AnyNdk</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> NDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【NDK系列3】c语言 结构体和共用体</title>
      <link href="/android/ndk/ndk-3/"/>
      <url>/android/ndk/ndk-3/</url>
      
        <content type="html"><![CDATA[<p>感觉c这块的内容真的无比枯燥，但在整理的过程中确实又学会了很多</p><p>这篇主要讲c语言里的<strong>结构体</strong>和<strong>共用体</strong></p><a id="more"></a><h2 id="一、结构体"><a href="#一、结构体" class="headerlink" title="一、结构体"></a>一、结构体</h2><h3 id="1-声明和使用"><a href="#1-声明和使用" class="headerlink" title="1. 声明和使用"></a>1. 声明和使用</h3><p>结构体是C编程中一种用户自定义的数据类型，类似于Java的JavaBean</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般定义变量 student a </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">50</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125; student,a;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用typedef定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125; Student;</span><br></pre></td></tr></table></figure><p>当结构体需要内存过大，使用动态内存申请。结构体占用字节数和结构体内字段有关，指针占用内存就是4/8字节，因此传指针比传值效率更高。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Student *s = (Student*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Student));</span><br><span class="line"><span class="built_in">memset</span>(s,<span class="number">0</span>,<span class="keyword">sizeof</span>(Student));</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, s-&gt;age);</span><br></pre></td></tr></table></figure><h3 id="2-字节对齐"><a href="#2-字节对齐" class="headerlink" title="2. 字节对齐"></a>2. 字节对齐</h3><p>内存空间按照字节划分，理论上可以从任何起始地址访问任意类型的变量。</p><p>但实际中在访问特定类型变量时经常在特定的内存地址开始访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序一个接一个地存放，这就是对齐。 </p><p>字节对齐的问题主要就是针对结构体。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Struct1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">short</span> a;  </span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">short</span> c; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Struct2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">short</span> a;</span><br><span class="line"><span class="keyword">short</span> c; </span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// short = 2  补 2</span></span><br><span class="line"><span class="comment">// int = 4</span></span><br><span class="line"><span class="comment">// short = 2  补 2</span></span><br><span class="line"><span class="keyword">sizeof</span>(Struct1) = <span class="number">12</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 2个short在一起组成一个 4 </span></span><br><span class="line"><span class="comment">// int = 4</span></span><br><span class="line"><span class="keyword">sizeof</span>(Struct2) = <span class="number">8</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>指定对齐位数</strong></p><p><code>#pragma pack(n)</code>的意思是告诉编译器字节对齐方式为n字节对齐，n字节对齐就是说变量存放的起始地址的偏移量有两种情况：</p><ul><li><p>第一、如果n大于等于该变量所占用的字节数，那么偏移量必须满足默认的对齐方式，</p></li><li><p>第二、如果n小于该变量的类型所占用的字节数，那么偏移量为n的倍数，不用满足默认的对齐方式。</p></li></ul><p>结构的总大小也有个约束条件，分下面两种情况：</p><p>如果n大于所有成员变量类型所占用的字节数，那么结构的总大小必须为占用空间最大的变量占用的空间数的倍数；否则必须为n的倍数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(2) <span class="comment">//指定以2字节对齐</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">short</span> a;  </span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">short</span> c; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()<span class="comment">//取消对齐</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//short = 2</span></span><br><span class="line"><span class="comment">//int = 4      用2的倍数进行对齐</span></span><br><span class="line"><span class="comment">//short = 2</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="二、共用体"><a href="#二、共用体" class="headerlink" title="二、共用体"></a>二、共用体</h2><p>在相同的内存位置存储不同的数据类型</p><p>共用体占用的内存应足够存储共用体中最大的成员</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//占用4字节</span></span><br><span class="line"><span class="keyword">union</span> Data</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">short</span> j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">union</span> Data data;</span><br><span class="line"></span><br><span class="line">data.i = <span class="number">1</span>;        <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//i的数据损坏</span></span><br><span class="line">data.j = <span class="number">1.1f</span>;     <span class="number">1</span></span><br></pre></td></tr></table></figure><p>共用体在一般的编程中应用较少，在单片机中应用较多。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://github.com/ddssingsong/AnyNdk" target="_blank" rel="noopener">https://github.com/ddssingsong/AnyNdk</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> NDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【NDK系列2】c语言 指针、函数、预处理器</title>
      <link href="/android/ndk/ndk-2/"/>
      <url>/android/ndk/ndk-2/</url>
      
        <content type="html"><![CDATA[<p>这是我们NDK学习的第二课，了解下c语言中<strong>指针</strong>、<strong>函数</strong>、<strong>预处理器</strong></p><p><em><a id="more"></a></em></p><h2 id="一、指针"><a href="#一、指针" class="headerlink" title="一、指针"></a>一、指针</h2><p>指针是一个变量，其值为地址，声明指针或者不再使用后都要将其置为0 (NULL)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *a; 正规</span><br><span class="line"><span class="keyword">int</span>* a;</span><br><span class="line"><span class="keyword">int</span> * a;</span><br><span class="line"><span class="comment">//因为 其他写法看起来有歧义</span></span><br><span class="line"><span class="keyword">int</span>* a,b;</span><br></pre></td></tr></table></figure><ul><li><p><strong>野指针</strong>        未初始化的指针</p></li><li><p><strong>悬空指针</strong>      指针最初指向的内存已经被释放了的一种指针</p></li><li><p><strong>具体使用</strong></p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一个整型变量</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//将i的地址使用取地址符给p指针</span></span><br><span class="line"><span class="keyword">int</span> *p = &amp;i;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出 0xffff 16进制地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%#x\n"</span>, &amp;i);     <span class="number">0xdaf3bab4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%#x\n"</span>, &amp;p);     <span class="number">0xdaf3baa8</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>指针多少个字节？</strong></p><p>指针指向地址，存放的是地址 </p><p>地址在 32位中指针占用4字节 64为8</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//32位：</span><br><span class="line">sizeof(p) == 4;</span><br><span class="line">//64位:</span><br><span class="line">sizeof(p) == 8;</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-解引用"><a href="#1-解引用" class="headerlink" title="1. 解引用"></a>1. 解引用</h3><p>解析并返回内存地址中保存的值，这个特性主要用于函数传值并修改参数的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;i;</span><br><span class="line"></span><br><span class="line"><span class="comment">//p指向一个内存地址，使用*解出这个地址的值 即为 10</span></span><br><span class="line"><span class="keyword">int</span> pv = *p;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改地址的值,则i值也变成100</span></span><br><span class="line">*p = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);    <span class="number">100</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p);   <span class="number">100</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, pv);   <span class="number">10</span></span><br></pre></td></tr></table></figure><h3 id="2-指针运算"><a href="#2-指针运算" class="headerlink" title="2. 指针运算"></a>2. 指针运算</h3><p>我们可以使用指针来读取和修改对象</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i1[] = &#123;<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p1 = i1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//*p1 指向第一个数据 11，移动指针就指向第二个了</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p1++); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-数组和指针"><a href="#3-数组和指针" class="headerlink" title="3. 数组和指针"></a>3. 数组和指针</h3><p>在c语言中，指针和数组名都表示地址</p><ul><li><p>数组是一块内存连续的数据。 </p></li><li><p>指针是一个指向内存空间的变量 </p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i1[] = &#123;<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接输出数组名会得到数组首元素的地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%#x\n"</span>,i1);   <span class="number">0xdaf3baa0</span></span><br><span class="line"><span class="comment">//解引用</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,*i1);   <span class="number">11</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//将数组名赋值给一个指针，这时候指针指向数组首元素地址</span></span><br><span class="line"><span class="keyword">int</span> *p1 = i1;</span><br></pre></td></tr></table></figure><h4 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二维数组类型是 int (*p)[x]</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">2</span>][<span class="number">3</span>] = &#123; &#123;<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>&#125;,&#123;<span class="number">44</span>,<span class="number">55</span>,<span class="number">66</span>&#125; &#125;;</span><br><span class="line"><span class="comment">//array1 就是一个 int[3] 类型的指针</span></span><br><span class="line"><span class="keyword">int</span> (*array1)[<span class="number">3</span>] = <span class="built_in">array</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//怎么取 55 ？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过下标</span></span><br><span class="line"><span class="built_in">array</span>[<span class="number">1</span>][<span class="number">1</span>] == array1[<span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过解引用</span></span><br><span class="line"><span class="keyword">int</span> i = *(*(array1 + <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);      <span class="number">55</span></span><br></pre></td></tr></table></figure><h4 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h4><p><a href="https://baike.baidu.com/item/数组/3794097" target="_blank" rel="noopener">数组</a>元素全为<a href="https://baike.baidu.com/item/指针/2878304" target="_blank" rel="noopener">指针</a>变量的数组称为指针数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *array2[<span class="number">2</span>];</span><br><span class="line">array2[<span class="number">0</span>] = &amp;i;</span><br><span class="line">array2[<span class="number">1</span>] = &amp;j;</span><br></pre></td></tr></table></figure><h3 id="4-const关键字"><a href="#4-const关键字" class="headerlink" title="4. const关键字"></a>4. const关键字</h3><p>常量修饰符</p><p><strong>const char * </strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *p = str;</span><br><span class="line">str[<span class="number">0</span>] = <span class="string">'c'</span>; <span class="comment">//正确</span></span><br><span class="line">p[<span class="number">0</span>] = <span class="string">'c'</span>;   <span class="comment">//错误 不能通过指针修改 const char</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以修改p的指向，指向其他的数据</span></span><br><span class="line">p = <span class="string">"12345"</span>;</span><br></pre></td></tr></table></figure><p><strong>char const *</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//性质和 const char * 一样</span></span><br><span class="line"><span class="keyword">char</span> <span class="keyword">const</span> *p1;</span><br></pre></td></tr></table></figure><p><strong>char * const</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[] = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//p2是一个const指针 指向char类型数据</span></span><br><span class="line"><span class="keyword">char</span> * <span class="keyword">const</span> p2 = str;</span><br><span class="line"></span><br><span class="line">p2[<span class="number">0</span>] = <span class="string">'d'</span>;  <span class="comment">//正确</span></span><br><span class="line">p2 = <span class="string">"12345"</span>; <span class="comment">//错误</span></span><br></pre></td></tr></table></figure><p><strong>char const* const</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[] = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// p3是一个const的指针变量 意味着不能修改它的指向</span></span><br><span class="line"><span class="comment">// 同时指向一个 const char 类型 意味着不能修改它指向的字符</span></span><br><span class="line"><span class="comment">// 集合了 const char * 与  char * const</span></span><br><span class="line"><span class="keyword">char</span> <span class="keyword">const</span>* <span class="keyword">const</span> p3 = str;</span><br></pre></td></tr></table></figure><h3 id="5-多级指针"><a href="#5-多级指针" class="headerlink" title="5. 多级指针"></a>5. 多级指针</h3><p>指向指针的指针</p><p>一个指针包含一个变量的地址。当我们定义一个指向指针的指针时，第一个指针包含了第二个指针的地址，第二个指针指向包含实际值的位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *i = &amp;a;</span><br><span class="line"><span class="keyword">int</span> **j = &amp;i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// *j 解出 i   </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, **j);</span><br></pre></td></tr></table></figure><p>多级指针的意义!  ——&gt;函数的引用传值</p><h2 id="二、函数"><a href="#二、函数" class="headerlink" title="二、函数"></a>二、函数</h2><h3 id="1-函数调用"><a href="#1-函数调用" class="headerlink" title="1. 函数调用"></a>1. 函数调用</h3><p>C中的函数与java没有区别。都是一组一起执行一个任务的语句，也都由 <strong>函数头</strong>与<strong>函数体</strong>构成</p><p>在使用之前必须声明</p><h5 id="传值调用"><a href="#传值调用" class="headerlink" title="传值调用"></a>传值调用</h5><p>把参数的值复制给函数的形式参数。修改形参不会影响实参</p><h5 id="引用调用"><a href="#引用调用" class="headerlink" title="引用调用"></a>引用调用</h5><p>形参为指向实参地址的指针，可以通过指针修改实参。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change1</span><span class="params">(<span class="keyword">int</span> *i)</span> </span>&#123;</span><br><span class="line">*i = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change2</span><span class="params">(<span class="keyword">int</span> *i)</span> </span>&#123;</span><br><span class="line">*i = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">change1(i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i); <span class="comment">//i == 1</span></span><br><span class="line"></span><br><span class="line">change2(&amp;i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i); <span class="comment">//i == 10</span></span><br></pre></td></tr></table></figure><h3 id="2-可变参数"><a href="#2-可变参数" class="headerlink" title="2. 可变参数"></a>2. 可变参数</h3><p>与Java一样，C当中也有可变参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addR</span><span class="params">(<span class="keyword">int</span> num, ...)</span> </span>&#123;</span><br><span class="line">    va_list valist;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    va_start(valist, num);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        <span class="comment">//访问参数</span></span><br><span class="line">        <span class="keyword">int</span> j = va_arg(valist, <span class="keyword">int</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, j);</span><br><span class="line">        sum += j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//清理</span></span><br><span class="line">    va_end(valist);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// ------------调用----------------</span></span><br><span class="line">   <span class="keyword">int</span> sum =  addR(<span class="number">3</span>, <span class="number">21</span>, <span class="number">122</span>, <span class="number">32</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"sum :%d\n"</span>, sum);    <span class="number">175</span></span><br></pre></td></tr></table></figure><h3 id="3-函数指针"><a href="#3-函数指针" class="headerlink" title="3. 函数指针"></a>3. 函数指针</h3><p>函数指针是指向函数的指针变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">println</span><span class="params">(<span class="keyword">char</span> *buffer)</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接受一个函数作为参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">(<span class="keyword">void</span>(*p)(<span class="keyword">char</span>*), <span class="keyword">char</span> *buffer)</span> </span>&#123;</span><br><span class="line">p(buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值函数</span></span><br><span class="line"><span class="keyword">void</span>(*p)(<span class="keyword">char</span>*) = println;</span><br><span class="line"></span><br><span class="line">p(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//传递参数</span></span><br><span class="line">say(println, <span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//typedef 创建别名 由编译器执行解释</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*Fun)</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br><span class="line">Fun fun = println;</span><br><span class="line"></span><br><span class="line">fun(<span class="string">"hello"</span>);</span><br><span class="line">say(fun, <span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------类似java的回调函数------------------</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*Callback)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(Callback callback)</span> </span>&#123;</span><br><span class="line">callback(<span class="string">"成功"</span>);</span><br><span class="line">callback(<span class="string">"失败"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(<span class="keyword">char</span> *msg)</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(callback);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不使用别名则是这么调用</span></span><br><span class="line"><span class="keyword">void</span> (*p)(<span class="keyword">char</span> *) = callback;</span><br><span class="line">test(p);</span><br></pre></td></tr></table></figure><h2 id="三、预处理器"><a href="#三、预处理器" class="headerlink" title="三、预处理器"></a>三、预处理器</h2><p>预处理器不是编译器，但是它是编译过程中一个单独的步骤，预处理器是一个文本替换工具，所有的预处理器命令都是以井号（#）开头</p><h4 id="1-常用预处理器"><a href="#1-常用预处理器" class="headerlink" title="1. 常用预处理器"></a>1. 常用预处理器</h4><table><thead><tr><th>预处理器</th><th>说明</th></tr></thead><tbody><tr><td>#include</td><td>导入头文件</td></tr><tr><td>#if</td><td>if</td></tr><tr><td>#elif</td><td>else if</td></tr><tr><td>#else</td><td>else</td></tr><tr><td>#endif</td><td>结束 if</td></tr><tr><td>#define</td><td>宏定义</td></tr><tr><td>#ifdef</td><td>如果定义了宏</td></tr><tr><td>#ifndef</td><td>如果未定义宏</td></tr><tr><td>#undef</td><td>取消宏定义</td></tr></tbody></table><h4 id="2-宏"><a href="#2-宏" class="headerlink" title="2. 宏"></a>2. 宏</h4><p>预处理器是一个文本替换工具，宏就是文本替换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//宏一般使用大写区分</span></span><br><span class="line"><span class="comment">//宏变量</span></span><br><span class="line"><span class="comment">//在代码中使用 A 就会被替换为1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> A 1</span></span><br></pre></td></tr></table></figure><p>宏函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//宏函数</span></span><br><span class="line"><span class="meta">#defind test(i) i &gt; 10 ? 1: 0</span></span><br></pre></td></tr></table></figure><p>其他</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// \ 换行符</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINT_I(arg) <span class="meta-keyword">if</span>(arg) &#123; \</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,arg); \</span><br><span class="line"> &#125;</span><br><span class="line">PRINT_I(dn_i);</span><br><span class="line"></span><br><span class="line"><span class="comment">//可变宏</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGE(...) __android_log_print(ANDROID_LOG_ERROR,<span class="meta-string">"NDK"</span>, __VA_ARGS__);</span></span><br></pre></td></tr></table></figure><p>宏函数</p><p>优点：<br>    文本替换，每个使用到的地方都会替换为宏定义。<br>    不会造成函数调用的开销（开辟栈空间，记录返回地址，将形参压栈，从函数返回还要释放堆栈。）<br>缺点：<br>    生成的目标文件大，不会执行代码检查</p><h4 id="3-内联函数"><a href="#3-内联函数" class="headerlink" title="3. 内联函数"></a>3. 内联函数</h4><p>和宏函数工作模式相似，但是两个不同的概念，首先是函数，那么就会有类型检查同时也可以debug</p><p>在编译时候将内联函数插入。</p><p>不能包含复杂的控制语句，while、switch，并且内联函数本身不能直接调用自身。</p><p>如果内联函数的函数体过大，编译器会自动的把这个内联函数变成普通函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="comment">//函数定义为inline即:内联函数  </span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span>* <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line"><span class="keyword">return</span> (i % <span class="number">2</span> &gt; <span class="number">0</span>) ? <span class="string">"奇"</span> : <span class="string">"偶"</span>;  </span><br><span class="line">&#125;   </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;  </span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>; i &lt; <span class="number">100</span>; i++) </span><br><span class="line">&#123;  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"i:%d    奇偶性:%s /n"</span>, i, dbtest(i));      </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在内部的工作就是在每个for循环的内部任何调用test(i)的地方都换成了(i%2&gt;0)?”奇”:”偶”这样就避免了频繁调用函数对栈内存重复开辟所带来的消耗。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://github.com/ddssingsong/AnyNdk" target="_blank" rel="noopener">https://github.com/ddssingsong/AnyNdk</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> NDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【NDK系列1】c语言基本数据类型和内存布局</title>
      <link href="/android/ndk/ndk-1/"/>
      <url>/android/ndk/ndk-1/</url>
      
        <content type="html"><![CDATA[<p>这是我们NDK学习的第一课，了解下c语言的<strong>数据类型</strong>和数组的<strong>内存布局</strong></p><a id="more"></a><h2 id="一、基本数据类型"><a href="#一、基本数据类型" class="headerlink" title="一、基本数据类型"></a>一、基本数据类型</h2><h3 id="1-整数类型"><a href="#1-整数类型" class="headerlink" title="1. 整数类型"></a>1. 整数类型</h3><ul><li><strong>signed</strong>——&gt;有符号，可修饰 char、int。Int是默认有符号的。</li><li><strong>unsigned</strong>——&gt;无符号，可修饰 int 、char</li></ul><p><br></p><p>基本类型如下</p><table><thead><tr><th style="text-align:left">整型</th><th>字节</th><th>取值范围</th><th>占位</th></tr></thead><tbody><tr><td style="text-align:left">int</td><td>4</td><td>-2,147,483,648 到 2,147,483,647</td><td>%d</td></tr><tr><td style="text-align:left">unsigned int</td><td>4</td><td>0 到 4,294,967,295</td><td>%u</td></tr><tr><td style="text-align:left">short</td><td>2</td><td>-32,768 到 32,767</td><td>%hd</td></tr><tr><td style="text-align:left">unsigned short</td><td>2</td><td>0 到 65,535</td><td>%hu</td></tr><tr><td style="text-align:left">long</td><td>4</td><td>-2,147,483,648 到 2,147,483,647</td><td>%ld</td></tr><tr><td style="text-align:left">unsigned long</td><td>4</td><td>0 到 4,294,967,295</td><td>%lu</td></tr><tr><td style="text-align:left">char</td><td>1</td><td>-128 到 127</td><td>%c</td></tr><tr><td style="text-align:left">unsigned char</td><td>1</td><td>0 到 255</td><td>%c</td></tr></tbody></table><p><br></p><p><strong>tips:</strong></p><ol><li><p>为了得到某个类型或某个变量在特定平台上的准确大小，使用 sizeof 运算符。</p><p>表达式 sizeof(type) 得到对象或类型的存储字节大小。</p></li><li><p>long int 其实就是长整型 = long 可以省去int，在标准中,规定 int至少和short一样长，long至少和int一样长。</p></li><li><p>为什么会存在long?</p><p>long和int在早期16位电脑时候 int 2字节，long 4字节，而计算机发展到现在，一般32、64下，long和int一样。和java类比的话，java的long就是 long long 8字节</p></li></ol><h3 id="2-浮点数类型"><a href="#2-浮点数类型" class="headerlink" title="2. 浮点数类型"></a>2. 浮点数类型</h3><p>浮点数类型如下</p><table><thead><tr><th>浮点型</th><th>字节</th><th>精度</th><th>占位</th></tr></thead><tbody><tr><td>float</td><td>4</td><td>6位小数</td><td>%f</td></tr><tr><td>double</td><td>8</td><td>15位小数</td><td>%lf</td></tr><tr><td>long double</td><td>8</td><td>19位小数</td><td>%Lf</td></tr></tbody></table><h3 id="3-其他"><a href="#3-其他" class="headerlink" title="3. 其他"></a>3. 其他</h3><p>关于8进制和16进制的打印显示</p><table><thead><tr><th>进制</th><th>打印参数</th></tr></thead><tbody><tr><td>8进制</td><td>%o</td></tr><tr><td>16进制</td><td>小写： %x    大写：%X</td></tr><tr><td>(0x)+16进制</td><td>%#x</td></tr></tbody></table><p><br></p><p><strong>tips :</strong></p><p> C99标准以前，C语言里面是没有bool，C++里面才有，C99标准里面定义了bool类型，需要引入头文件stdbool.h<br>bool类型有只有两个值：<strong>true =1 、false=0</strong>，因此实际上bool就是一个int所以在c/c++中 if 遵循一个规则， <strong>非0为true，非空为true</strong>；NULL 其实也就是被define为了 0 </p><h2 id="二、格式化输出"><a href="#二、格式化输出" class="headerlink" title="二、格式化输出"></a>二、格式化输出</h2><p>函数printf、sprintf</p><p>将格式化的数据写入第一个参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印</span></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(str, <span class="string">"img/png_%d.png"</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>, str);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 0 补到3个字符</span></span><br><span class="line"><span class="built_in">sprintf</span>(str, <span class="string">"img/png_%03d.png"</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>, str);</span><br></pre></td></tr></table></figure><h2 id="三、数组与内存布局"><a href="#三、数组与内存布局" class="headerlink" title="三、数组与内存布局"></a>三、数组与内存布局</h2><p>数组 ： 连续的内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java</span></span><br><span class="line"><span class="keyword">int</span>[] a</span><br><span class="line"></span><br><span class="line"><span class="comment">//c</span></span><br><span class="line"><span class="comment">//必须声明时候确定大小</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>]  </span><br><span class="line"><span class="comment">//或者 直接初始化 </span></span><br><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,<span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure><p><strong>tips</strong></p><p>栈内存限制 查看 linux：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -a</span><br></pre></td></tr></table></figure><p>但是直接分配这么大不行，因为堆栈可能保存参数，返回地址等等信息</p><h3 id="1-动态内存申请"><a href="#1-动态内存申请" class="headerlink" title="1. 动态内存申请"></a>1. 动态内存申请</h3><h4 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h4><p>​    没有初始化内存的内容,一般调用函数memset来初始化这部分的内存空间.</p><h4 id="calloc"><a href="#calloc" class="headerlink" title="calloc"></a>calloc</h4><p>​    申请内存并将初始化内存数据为NULL.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pn = (<span class="keyword">int</span>)<span class="built_in">calloc</span>(<span class="number">10</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure><h4 id="realloc"><a href="#realloc" class="headerlink" title="realloc"></a>realloc</h4><p>​     对malloc申请的内存进行大小的调整.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *a = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">realloc</span>(a,<span class="number">20</span>);</span><br></pre></td></tr></table></figure><h4 id="alloca"><a href="#alloca" class="headerlink" title="alloca"></a>alloca</h4><p>特别的：在栈申请内存,因此无需释放.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span> *)alloca(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">10</span>);</span><br></pre></td></tr></table></figure><h3 id="2-物理内存和虚拟内存"><a href="#2-物理内存和虚拟内存" class="headerlink" title="2. 物理内存和虚拟内存"></a>2. 物理内存和虚拟内存</h3><h4 id="物理内存"><a href="#物理内存" class="headerlink" title="物理内存"></a>物理内存</h4><p>​    物理内存指通过物理内存条而获得的内存空间</p><h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><p>​    一种内存管理技术<br>​    电脑中所运行的程序均需经由内存执行，若执行的程序占用内存很大，则会导致内存消耗殆尽。<br>​    虚拟内存技术还会匀出一部分硬盘空间来充当内存使用。</p><p><img src="https://img-blog.csdnimg.cn/2019061821310711.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTEwNzcwMjc=,size_16,color_FFFFFF,t_70" alt=""></p><p>进程分配内存主要由两个系统调用完成：<strong>brk和mmap</strong> 。</p><ol><li>brk是将_edata(指带堆位置的指针)往高地址推；</li><li>mmap 找一块空闲的虚拟内存。</li></ol><p>通过glibc (C标准库)中提供的malloc函数完成内存申请</p><p>malloc小于128k的内存，使用brk分配内存，将_edata往高地址推,大于128k则使用mmap</p><p>存放程序执行代码（cpu要执行的指令）</p><blockquote><p>栈是向低地址扩展数据结构<br>堆是向高地址扩展数据结构</p></blockquote><h2 id="代码收录"><a href="#代码收录" class="headerlink" title="代码收录"></a>代码收录</h2><p><a href="https://github.com/ddssingsong/AnyNdk" target="_blank" rel="noopener">https://github.com/ddssingsong/AnyNdk</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> NDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>更自由的布局</title>
      <link href="/example/%E6%9B%B4%E8%87%AA%E7%94%B1%E7%9A%84%E5%B8%83%E5%B1%80/"/>
      <url>/example/%E6%9B%B4%E8%87%AA%E7%94%B1%E7%9A%84%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<p>现在（<code>1.2.4 以及更高版本</code>）主题配置文件中旧的侧边栏配置依旧不变，在此基础上新增了<code>layout</code>字段专门用于控制页面显示什么。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">layout:</span></span><br><span class="line">  <span class="comment"># 文章列表（主页、自定义的列表）布局</span></span><br><span class="line"><span class="attr">  posts:</span></span><br><span class="line">    <span class="comment"># 列表中每一篇文章的meta信息</span></span><br><span class="line"><span class="attr">    meta:</span> <span class="string">[title,</span> <span class="string">author,</span> <span class="string">date,</span> <span class="string">categories,</span> <span class="string">top]</span></span><br><span class="line">    <span class="comment"># 列表类页面的侧边栏</span></span><br><span class="line"><span class="attr">    sidebar:</span> <span class="string">[author,</span> <span class="string">grid,</span> <span class="string">category,</span> <span class="string">tagcloud,</span> <span class="string">list]</span></span><br><span class="line">  <span class="comment"># 文章页面布局</span></span><br><span class="line"><span class="attr">  article:</span></span><br><span class="line">    <span class="comment"># 文章页面主体元素，你也可以在页面的Front-matter中设置</span></span><br><span class="line"><span class="attr">    body:</span> <span class="string">[article,</span> <span class="string">comments]</span></span><br><span class="line">    <span class="comment"># 默认的meta信息，文章中没有配置则按照这里的配置来显示，设置为false则不显示</span></span><br><span class="line">    <span class="comment"># 其中，title只在header中有效，music和thumbnail无需在这里设置，文章中有则显示</span></span><br><span class="line">    <span class="comment"># 如果tags放置在meta.header中，那么在post列表中不显示（因为卡片下方已经有了）</span></span><br><span class="line"><span class="attr">    header:</span> <span class="string">[title,</span> <span class="string">author,</span> <span class="string">date,</span> <span class="string">categories,</span> <span class="string">counter,</span> <span class="string">top]</span></span><br><span class="line"><span class="attr">    footer:</span> <span class="string">[updated,</span> <span class="string">tags,</span> <span class="string">share]</span></span><br><span class="line">    <span class="comment"># 文章页面的侧边栏</span></span><br><span class="line"><span class="attr">    sidebar:</span> <span class="string">[author,</span> <span class="string">toc,</span> <span class="string">grid,</span> <span class="string">category,</span> <span class="string">tagcloud,</span> <span class="string">list,</span> <span class="string">related_posts]</span></span><br><span class="line">  <span class="comment"># 其他的页面布局暂时等于文章列表</span></span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>支持多用户</title>
      <link href="/example/%E5%A4%9A%E7%94%A8%E6%88%B7/"/>
      <url>/example/%E5%A4%9A%E7%94%A8%E6%88%B7/</url>
      
        <content type="html"><![CDATA[<p>在博客根目录中配置的属性是默认作者：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">author:</span> <span class="string">Mr.X</span></span><br><span class="line"><span class="attr">avatar:</span> <span class="attr">https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/avatar/avatar.png</span></span><br><span class="line"><span class="attr">url:</span> <span class="attr">http://mxclub.github.io</span></span><br></pre></td></tr></table></figure></p><p>在文章的Front-matter中可以配置本篇文章的作者：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">author:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">xaoxuu</span></span><br><span class="line"><span class="attr">  avatar:</span> <span class="attr">https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/avatar/avatar.png</span></span><br><span class="line"><span class="attr">  url:</span> <span class="attr">https://xaoxuu.com</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>写法示例：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">blog</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">支持多用户</span></span><br><span class="line"><span class="attr">author:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">xaoxuu</span></span><br><span class="line"><span class="attr">  avatar:</span> <span class="attr">https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/avatar/avatar.png</span></span><br><span class="line"><span class="attr">  url:</span> <span class="attr">https://xaoxuu.com</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2019</span><span class="bullet">-04</span><span class="bullet">-06</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">[Hexo,教程]</span></span><br><span class="line"><span class="attr">valine:</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">/top/</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>自定义meta信息</title>
      <link href="/example/%E8%87%AA%E5%AE%9A%E4%B9%89meta%E4%BF%A1%E6%81%AF/"/>
      <url>/example/%E8%87%AA%E5%AE%9A%E4%B9%89meta%E4%BF%A1%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<p>现在你可以在文章开头和末尾放置任意支持的meta标签，支持的标签有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">title</span><br><span class="line">author</span><br><span class="line">date</span><br><span class="line">updated</span><br><span class="line">categories</span><br><span class="line">tags</span><br><span class="line">counter</span><br><span class="line">top</span><br></pre></td></tr></table></figure></p><p>例如本文：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">blog</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">自定义meta信息</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2019</span><span class="bullet">-04</span><span class="bullet">-06</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">[Hexo,教程]</span></span><br><span class="line"><span class="attr">tags:</span> <span class="string">ss</span></span><br><span class="line"><span class="attr">meta:</span></span><br><span class="line"><span class="attr">  header:</span> <span class="string">[title,</span> <span class="string">author,</span> <span class="string">updated,</span> <span class="string">counter]</span></span><br><span class="line"><span class="attr">  footer:</span> <span class="string">[categories,</span> <span class="string">tags,</span> <span class="string">share]</span></span><br><span class="line"><span class="attr">valine:</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">/top/</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>如果不写，就按照主题配置文件中的显示。<br>如果不想显示任何meta标签，就写<code>false</code>，例如关于页面：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">关于</span></span><br><span class="line"><span class="attr">meta:</span></span><br><span class="line"><span class="attr">  header:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  footer:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">valine:</span></span><br><span class="line"><span class="attr">  placeholder:</span> <span class="string">有什么想对我说的呢？</span></span><br><span class="line"><span class="attr">sidebar:</span> <span class="literal">false</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>引用外部文章</title>
      <link href="/example/%E5%BC%95%E7%94%A8%E5%A4%96%E9%83%A8%E6%96%87%E7%AB%A0/"/>
      <url>/example/%E5%BC%95%E7%94%A8%E5%A4%96%E9%83%A8%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p>只需设置permalink即可：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">author:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">xaoxuu</span></span><br><span class="line"><span class="attr">  avatar:</span> <span class="attr">https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/avatar/avatar.png</span></span><br><span class="line"><span class="attr">  url:</span> <span class="attr">https://xaoxuu.com</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="attr">https://xaoxuu.com/wiki/material-x/</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></p><p>项目分类中的均为外部文章，<a href="/projects/">前往查看</a>。</p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多语言</title>
      <link href="/example/%E5%A4%9A%E8%AF%AD%E8%A8%80/"/>
      <url>/example/%E5%A4%9A%E8%AF%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<p>在主目录找到或者新增<code>language</code>，例如：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">en</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">zh-HK</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">zh-TW</span></span><br></pre></td></tr></table></figure><p>博客将按照给定的优先级显示语言。</p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>文章专属BGM</title>
      <link href="/example/%E6%96%87%E7%AB%A0%E4%B8%93%E5%B1%9EBGM/"/>
      <url>/example/%E6%96%87%E7%AB%A0%E4%B8%93%E5%B1%9EBGM/</url>
      
        <content type="html"><![CDATA[<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">文章专属BGM</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018</span><span class="bullet">-12</span><span class="bullet">-30</span></span><br><span class="line"><span class="attr">music:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">song</span>        <span class="comment"># song （单曲） album （专辑） playlist （歌单） search （搜索）</span></span><br><span class="line"><span class="attr">  id:</span> <span class="number">26664345</span>      <span class="comment"># 歌曲/专辑/歌单 ID</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>详情见文档：<a href="https://xaoxuu.com/wiki/material-x/third-party-services/" target="_blank" rel="noopener">https://xaoxuu.com/wiki/material-x/third-party-services/</a></p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>置顶：博客源码</title>
      <link href="/example/top/"/>
      <url>/example/top/</url>
      
        <content type="html"><![CDATA[<p>文章的Front-matter填写<code>top: true</code>就置顶了。<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">top:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>这是一个示例博客。源码目录：<a href="https://github.com/xaoxuu/blog-example" target="_blank" rel="noopener">https://github.com/xaoxuu/blog-example</a></p><a id="more"></a><p><img class="emoji tieba" src="https://cdn.jsdelivr.net/gh/xaoxuu/volantis@1.0/img/tieba/捂嘴笑.png">没有更多了哦。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>共用一个评论框</title>
      <link href="/example/%E5%85%B1%E7%94%A8%E4%B8%80%E4%B8%AA%E8%AF%84%E8%AE%BA%E6%A1%86/"/>
      <url>/example/%E5%85%B1%E7%94%A8%E4%B8%80%E4%B8%AA%E8%AF%84%E8%AE%BA%E6%A1%86/</url>
      
        <content type="html"><![CDATA[<p>写法示例：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">共用一个评论框</span></span><br><span class="line"><span class="attr">valine:</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">/top/</span></span><br><span class="line"><span class="attr">  placeholder:</span> <span class="string">你觉得共用一个评论框有意义吗？</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>摘要注意事项</title>
      <link href="/example/%E6%91%98%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
      <url>/example/%E6%91%98%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<p>如果使用<code>&lt;!-- more --&gt;</code>来实现摘要，则<code>&lt;!-- more --&gt;</code>前后一定要有空行，不然可能导致显示错位。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">这是摘要</span></span><br><span class="line"></span><br><span class="line"><span class="string">&lt;!--</span> <span class="string">more</span> <span class="bullet">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="string">这是正文</span></span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo.sh</title>
      <link href="/https://xaoxuu.com/wiki/hexo.sh//"/>
      <url>/https://xaoxuu.com/wiki/hexo.sh//</url>
      
        <content type="html"><![CDATA[<p><strong>一个方便管理与发布hexo博客的脚本。</strong></p><p><fancybox><img src="https://img.vim-cn.com/e8/e14f6ecb16deb21e894e78c9ccc46729854394.png" alt=""><fancybox></fancybox></fancybox></p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Material X</title>
      <link href="/https://xaoxuu.com/wiki/material-x//"/>
      <url>/https://xaoxuu.com/wiki/material-x//</url>
      
        <content type="html"><![CDATA[<p><strong>一个简约的卡片式Hexo博客主题。</strong></p><fancybox><br><img src="https://img.vim-cn.com/52/a54815c02ce232f11f54b2c547c1337828833c.png" alt=""><br></fancybox><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
          <category> materialX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Images</title>
      <link href="/test/images/"/>
      <url>/test/images/</url>
      
        <content type="html"><![CDATA[<p>This is a image test post.</p><p><img src="http://placehold.it/350x150.jpg" alt="Small Picture"></p>]]></content>
      
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Excerpts</title>
      <link href="/test/excerpts/"/>
      <url>/test/excerpts/</url>
      
        <content type="html"><![CDATA[<p>The following contents should be invisible in home/archive page.</p><a id="more"></a><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce eget urna vitae velit eleifend interdum at ac nisi. In nec ligula lacus. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Sed eu cursus erat, ut dapibus quam. Aliquam eleifend dolor vitae libero pharetra adipiscing. Etiam adipiscing dolor a quam tempor, eu convallis nulla varius. Aliquam sollicitudin risus a porta aliquam. Ut nec velit dolor. Proin eget leo lobortis, aliquam est sed, mollis mauris. Fusce vitae leo pretium massa accumsan condimentum. Fusce malesuada gravida lectus vel vulputate. Donec bibendum porta nibh ut aliquam.</p><p>Sed lorem felis, congue non fringilla eu, aliquam eu eros. Curabitur orci libero, mollis sed semper vitae, adipiscing in lectus. Aenean non egestas odio. Donec sollicitudin nisi quis lorem gravida, in pharetra mauris fringilla. Duis sit amet faucibus dolor, id aliquam neque. In egestas, odio gravida tempor dictum, mauris felis faucibus purus, sit amet commodo lacus diam vitae est. Ut ut quam eget massa semper sodales. Aenean non ipsum cursus, blandit lectus in, ornare odio. Curabitur ultrices porttitor vulputate.</p>]]></content>
      
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Videos</title>
      <link href="/test/videos/"/>
      <url>/test/videos/</url>
      
        <content type="html"><![CDATA[<p>This is a video test post.</p><p><strong>Youtube</strong></p><div class="video-container"><iframe src="//www.youtube.com/embed/TIbZDRXM-Tg" frameborder="0" allowfullscreen></iframe></div><p><strong>Vimeo</strong></p><div class="video-container"><iframe src="//player.vimeo.com/video/82090131" frameborder="0" allowfullscreen></iframe></div>]]></content>
      
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gallery Post</title>
      <link href="/test/gallery-post/"/>
      <url>/test/gallery-post/</url>
      
        <content type="html"><![CDATA[<p>This post contains 4 photos:</p><ul><li>Widescreen wallpaper</li><li>Portrait photo</li><li>Dual widescreen wallpaper</li><li>Small photo</li></ul><p>All photos should be displayed properly.</p><p><em>From <a href="http://wallbase.cc" target="_blank" rel="noopener">Wallbase.cc</a></em></p>]]></content>
      
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tag Plugins</title>
      <link href="/test/tag-plugins/"/>
      <url>/test/tag-plugins/</url>
      
        <content type="html"><![CDATA[<p>This post is used for testing tag plugins. See <a href="http://zespia.tw/hexo/docs/tag-plugins.html" target="_blank" rel="noopener">docs</a> for more info.</p><a id="more"></a><h2 id="Block-Quote"><a href="#Block-Quote" class="headerlink" title="Block Quote"></a>Block Quote</h2><h3 id="Normal-blockquote"><a href="#Normal-blockquote" class="headerlink" title="Normal blockquote"></a>Normal blockquote</h3><blockquote><p>Praesent diam elit, interdum ut pulvinar placerat, imperdiet at magna.</p></blockquote><h3 id="Quote-from-a-book"><a href="#Quote-from-a-book" class="headerlink" title="Quote from a book"></a>Quote from a book</h3><blockquote><p>Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.</p><footer><strong>David Levithan</strong><cite>Wide Awake</cite></footer></blockquote><h3 id="Quote-from-Twitter"><a href="#Quote-from-Twitter" class="headerlink" title="Quote from Twitter"></a>Quote from Twitter</h3><blockquote><p>NEW: DevDocs now comes with syntax highlighting. <a href="http://devdocs.io" target="_blank" rel="noopener">http://devdocs.io</a></p><footer><strong>@DevDocs</strong><cite><a href="https://twitter.com/devdocs/status/356095192085962752" target="_blank" rel="noopener">twitter.com/devdocs/status/356095192085962752</a></cite></footer></blockquote><h3 id="Quote-from-an-article-on-the-web"><a href="#Quote-from-an-article-on-the-web" class="headerlink" title="Quote from an article on the web"></a>Quote from an article on the web</h3><blockquote><p>Every interaction is both precious and an opportunity to delight.</p><footer><strong>Seth Godin</strong><cite><a href="http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html" target="_blank" rel="noopener">Welcome to Island Marketing</a></cite></footer></blockquote><h2 id="Code-Block"><a href="#Code-Block" class="headerlink" title="Code Block"></a>Code Block</h2><h3 id="Normal-code-block"><a href="#Normal-code-block" class="headerlink" title="Normal code block"></a>Normal code block</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(&apos;Hello World!&apos;);</span><br></pre></td></tr></table></figure><h3 id="With-caption"><a href="#With-caption" class="headerlink" title="With caption"></a>With caption</h3><figure class="highlight plain"><figcaption><span>Array.map</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.map(callback[, thisArg])</span><br></pre></td></tr></table></figure><h3 id="With-caption-and-URL"><a href="#With-caption-and-URL" class="headerlink" title="With caption and URL"></a>With caption and URL</h3><figure class="highlight plain"><figcaption><span>.compact</span><a href="http://underscorejs.org/#compact" target="_blank" rel="noopener">Underscore.js</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.compact([0, 1, false, 2, ‘’, 3]);</span><br><span class="line">=&gt; [1, 2, 3]</span><br></pre></td></tr></table></figure><h3 id="With-marked-lines"><a href="#With-marked-lines" class="headerlink" title="With marked lines"></a>With marked lines</h3><p>Line 1,7-8,10 should be marked with different color.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line marked"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hostname = <span class="string">'127.0.0.1'</span>;</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">1337</span>;</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line marked">  res.writeHead(<span class="number">200</span>, &#123; <span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span> &#125;);</span><br><span class="line marked">  res.end(<span class="string">'Hello World\n'</span>);</span><br><span class="line">&#125;).listen(port, hostname, () =&gt; &#123;</span><br><span class="line marked">  <span class="built_in">console</span>.log(<span class="string">`Server running at http://<span class="subst">$&#123;hostname&#125;</span>:<span class="subst">$&#123;port&#125;</span>/`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Note: Theme’s style should support <code>.highlight.line.marked</code> (recommend to use the selection or current line color).</p><h3 id="Gist"><a href="#Gist" class="headerlink" title="Gist"></a>Gist</h3><script src="//gist.github.com/996818.js"></script><h3 id="jsFiddle"><a href="#jsFiddle" class="headerlink" title="jsFiddle"></a>jsFiddle</h3><iframe scrolling="no" width="100%" height="300" src="//jsfiddle.net/ccWP7/embedded/js,resources,html,css,result/light" frameborder="0" allowfullscreen></iframe><h2 id="Pullquote"><a href="#Pullquote" class="headerlink" title="Pullquote"></a>Pullquote</h2><h3 id="Left"><a href="#Left" class="headerlink" title="Left"></a>Left</h3><blockquote class="pullquote left"><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p></blockquote><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Maecenas tempus molestie arcu, et fringilla mauris placerat ac. Nullam luctus bibendum risus. Ut cursus sed ipsum feugiat egestas. Suspendisse elementum, velit eu consequat consequat, augue lorem dapibus libero, eget pulvinar dolor est sit amet nulla. Suspendisse a porta tortor, et posuere mi. Pellentesque ultricies, mi quis volutpat malesuada, erat felis vulputate nisl, ac congue ante tortor ut ante. Proin aliquam sem vel mauris tincidunt, eget scelerisque tortor euismod. Nulla tincidunt enim nec commodo dictum. Mauris id sapien et orci gravida luctus id ut dui. In vel vulputate odio. Duis vel turpis molestie, scelerisque enim eu, lobortis eros. Cras at ipsum gravida, sagittis ante vel, viverra tellus. Nunc mauris turpis, elementum ullamcorper nisl pretium, ultrices cursus justo. Mauris porttitor commodo eros, ac ornare orci interdum in. Cras fermentum cursus leo sed mattis. In dignissim lorem sem, sit amet elementum mauris venenatis ac.</p><h3 id="Right"><a href="#Right" class="headerlink" title="Right"></a>Right</h3><blockquote class="pullquote right"><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p></blockquote><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed ligula justo, lobortis sit amet semper vel, dignissim sit amet libero. Praesent ac tempus ligula. Maecenas at gravida odio. Etiam tristique volutpat lacus eu faucibus. Donec non tempus arcu. Phasellus adipiscing, mauris nec mollis egestas, ipsum nunc auctor velit, et rhoncus lorem ipsum at ante. Praesent et sem in velit volutpat auctor. Duis vel mauris nulla. Maecenas mattis interdum ante, quis sagittis nibh cursus et. Nulla facilisi. Morbi convallis gravida tortor, ut fermentum enim gravida et. Nunc vel dictum nisl, non ultrices libero. Proin vestibulum felis eget orci consectetur lobortis. Vestibulum augue nulla, iaculis vitae augue vehicula, dignissim ultrices libero. Sed imperdiet urna et quam ultrices tincidunt nec ac magna. Etiam vel pharetra elit.</p>]]></content>
      
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日本語テスト</title>
      <link href="/test/%E6%97%A5%E6%9C%AC%E8%AA%9E%E3%83%86%E3%82%B9%E3%83%88/"/>
      <url>/test/%E6%97%A5%E6%9C%AC%E8%AA%9E%E3%83%86%E3%82%B9%E3%83%88/</url>
      
        <content type="html"><![CDATA[<p>This is a Japanese test post.</p><p>私は昨日ついにその助力家というのの上よりするたなけれ。</p><p>最も今をお話団はちょうどこの前後なかろでくらいに困りがいるたをは帰着考えたなかって、そうにもするでうたらない。</p><p>がたを知っないはずも同時に九月をいよいよたありた。</p><p>もっと槙さんにぼんやり金少し説明にえた自分大した人私か影響にというお関係たうませないが、この次第も私か兄具合に使うて、槙さんののに当人のあなたにさぞご意味と行くて私個人が小尊敬を聴いように同時に同反抗に集っだうて、いよいよまず相当へあっうからいだ事をしでなけれ。</p><blockquote><p>それでそれでもご時日をしはずはたったいやと突き抜けるますて、その元がは行ったてという獄を尽すていけですた。</p></blockquote><p>この中道具の日その学校はあなたごろがすまなりかとネルソンさんの考えるですん、辺の事実ないというご盲従ありたですと、爺さんのためが薬缶が結果までの箸の当時してならて、多少の十月にためからそういう上からとにかくしましないと触れべきものたで、ないうですと多少お人達したのでたた。</p><p><em>From <a href="http://lipsum.sugutsukaeru.jp/index.cgi" target="_blank" rel="noopener">すぐ使えるダミーテキスト - 日本語 Lorem ipsum</a></em></p>]]></content>
      
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中文測試</title>
      <link href="/test/%E4%B8%AD%E6%96%87%E6%B8%AC%E8%A9%A6/"/>
      <url>/test/%E4%B8%AD%E6%96%87%E6%B8%AC%E8%A9%A6/</url>
      
        <content type="html"><![CDATA[<p>This is a Chinese test post.</p><p>燕子去了，有再来的时候；杨柳枯了，有再青的时候；桃花谢了，有再开的时候。但是，聪明的，你告诉我，我们的日子为什么一去不复返呢？——是有人偷了他们罢：那是谁？又藏在何处呢？是他们自己逃走了罢：现在又到了哪里呢？</p><p>　　我不知道他们给了我多少日子；但我的手确乎是渐渐空虚了。在默默里算着，八千多日子已经从我手中溜去；像针尖上一滴水滴在大海里，我的日子滴在时间的流里，没有声音，也没有影子。我不禁头涔涔而泪潸潸了。</p><p>　　去的尽管去了，来的尽管来着；去来的中间，又怎样地匆匆呢？早上我起来的时候，小屋里射进两三方斜斜的太阳。太阳他有脚啊，轻轻悄悄地挪移了；我也茫茫然跟着旋转。于是——洗手的时候，日子从水盆里过去；吃饭的时候，日子从饭碗里过去；默默时，便从凝然的双眼前过去。我觉察他去的匆匆了，伸出手遮挽时，他又从遮挽着的手边过去，天黑时，我躺在床上，他便伶伶俐俐地从我身上跨过，从我脚边飞去了。等我睁开眼和太阳再见，这算又溜走了一日。我掩着面叹息。但是新来的日子的影儿又开始在叹息里闪过了。</p><p>　　在逃去如飞的日子里，在千门万户的世界里的我能做些什么呢？只有徘徊罢了，只有匆匆罢了；在八千多日的匆匆里，除徘徊外，又剩些什么呢？过去的日子如轻烟，被微风吹散了，如薄雾，被初阳蒸融了；我留着些什么痕迹呢？我何曾留着像游丝样的痕迹呢？我赤裸裸来到这世界，转眼间也将赤裸裸的回去罢？但不能平的，为什么偏要白白走这一遭啊？</p><p>　　你聪明的，告诉我，我们的日子为什么一去不复返呢？</p><p>　　1922年3月28日</p><blockquote><p>工步他始能詩的，裝進分星海演意學值例道……於財型目古香亮自和這乎？化經溫詩。只賽嚴大一主價世哥受的沒有中年即病行金拉麼河。主小路了種就小為廣不？</p></blockquote><p><em>From <a href="http://www.richyli.com/tool/loremipsum/" target="_blank" rel="noopener">亂數假文產生器 - Chinese Lorem Ipsum</a></em></p>]]></content>
      
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam justo turpis, tincidunt ac convallis id.</title>
      <link href="/test/long-title/"/>
      <url>/test/long-title/</url>
      
        <content type="html"><![CDATA[<p>This post has a long title. Make sure the title displayed right.</p>]]></content>
      
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Link Post</title>
      <link href="/test/link-post/"/>
      <url>/test/link-post/</url>
      
        <content type="html"><![CDATA[<p>This is a link post. Clicking on the link should open <a href="http://www.google.com/" target="_blank" rel="noopener">Google</a> in a new tab or window.</p>]]></content>
      
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elements</title>
      <link href="/test/elements/"/>
      <url>/test/elements/</url>
      
        <content type="html"><![CDATA[<p>The purpose of this post is to help you make sure all of HTML elements can display properly. If you use CSS reset, don’t forget to redefine the style by yourself.</p><hr><h1 id="Heading-1"><a href="#Heading-1" class="headerlink" title="Heading 1"></a>Heading 1</h1><h2 id="Heading-2"><a href="#Heading-2" class="headerlink" title="Heading 2"></a>Heading 2</h2><h3 id="Heading-3"><a href="#Heading-3" class="headerlink" title="Heading 3"></a>Heading 3</h3><h4 id="Heading-4"><a href="#Heading-4" class="headerlink" title="Heading 4"></a>Heading 4</h4><h5 id="Heading-5"><a href="#Heading-5" class="headerlink" title="Heading 5"></a>Heading 5</h5><h6 id="Heading-6"><a href="#Heading-6" class="headerlink" title="Heading 6"></a>Heading 6</h6><hr><h2 id="Paragraph"><a href="#Paragraph" class="headerlink" title="Paragraph"></a>Paragraph</h2><p>Lorem ipsum dolor sit amet, <a href="">test link</a> consectetur adipiscing elit. <strong>Strong text</strong> pellentesque ligula commodo viverra vehicula. <em>Italic text</em> at ullamcorper enim. Morbi a euismod nibh. <u>Underline text</u> non elit nisl. <del>Deleted text</del> tristique, sem id condimentum tempus, metus lectus venenatis mauris, sit amet semper lorem felis a eros. Fusce egestas nibh at sagittis auctor. Sed ultricies ac arcu quis molestie. Donec dapibus nunc in nibh egestas, vitae volutpat sem iaculis. Curabitur sem tellus, elementum nec quam id, fermentum laoreet mi. Ut mollis ullamcorper turpis, vitae facilisis velit ultricies sit amet. Etiam laoreet dui odio, id tempus justo tincidunt id. Phasellus scelerisque nunc sed nunc ultricies accumsan.</p><p>Interdum et malesuada fames ac ante ipsum primis in faucibus. <code>Sed erat diam</code>, blandit eget felis aliquam, rhoncus varius urna. Donec tellus sapien, sodales eget ante vitae, feugiat ullamcorper urna. Praesent auctor dui vitae dapibus eleifend. Proin viverra mollis neque, ut ullamcorper elit posuere eget.</p><blockquote><p>Praesent diam elit, interdum ut pulvinar placerat, imperdiet at magna.</p></blockquote><p>Maecenas ornare arcu at mi suscipit, non molestie tortor ultrices. Aenean convallis, diam et congue ultricies, erat magna tincidunt orci, pulvinar posuere mi sapien ac magna. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Praesent vitae placerat mauris. Nullam laoreet ante posuere tortor blandit auctor. Sed id ligula volutpat leo consequat placerat. Mauris fermentum dolor sed augue malesuada sollicitudin. Vivamus ultrices nunc felis, quis viverra orci eleifend ut. Donec et quam id urna cursus posuere. Donec elementum scelerisque laoreet.</p><h2 id="List-Types"><a href="#List-Types" class="headerlink" title="List Types"></a>List Types</h2><h3 id="Definition-List-dl"><a href="#Definition-List-dl" class="headerlink" title="Definition List (dl)"></a>Definition List (dl)</h3><dl><dt>Definition List Title</dt><dd>This is a definition list division.</dd></dl><h3 id="Ordered-List-ol"><a href="#Ordered-List-ol" class="headerlink" title="Ordered List (ol)"></a>Ordered List (ol)</h3><ol><li>List Item 1</li><li>List Item 2</li><li>List Item 3</li></ol><h3 id="Unordered-List-ul"><a href="#Unordered-List-ul" class="headerlink" title="Unordered List (ul)"></a>Unordered List (ul)</h3><ul><li>List Item 1</li><li>List Item 2</li><li>List Item 3</li></ul><h2 id="Table"><a href="#Table" class="headerlink" title="Table"></a>Table</h2><table><thead><tr><th>Table Header 1</th><th>Table Header 2</th><th>Table Header 3</th></tr></thead><tbody><tr><td>Division 1</td><td>Division 2</td><td>Division 3</td></tr><tr><td>Division 1</td><td>Division 2</td><td>Division 3</td></tr><tr><td>Division 1</td><td>Division 2</td><td>Division 3</td></tr></tbody></table><h2 id="Misc-Stuff-abbr-acronym-sub-sup-etc"><a href="#Misc-Stuff-abbr-acronym-sub-sup-etc" class="headerlink" title="Misc Stuff - abbr, acronym, sub, sup, etc."></a>Misc Stuff - abbr, acronym, sub, sup, etc.</h2><p>Lorem <sup>superscript</sup> dolor <sub>subscript</sub> amet, consectetuer adipiscing elit. Nullam dignissim convallis est. Quisque aliquam. <cite>cite</cite>. Nunc iaculis suscipit dui. Nam sit amet sem. Aliquam libero nisi, imperdiet at, tincidunt nec, gravida vehicula, nisl. Praesent mattis, massa quis luctus fermentum, turpis mi volutpat justo, eu volutpat enim diam eget metus. Maecenas ornare tortor. Donec sed tellus eget sapien fringilla nonummy. <acronym title="National Basketball Association">NBA</acronym> Mauris a ante. Suspendisse quam sem, consequat at, commodo vitae, feugiat in, nunc. Morbi imperdiet augue quis tellus.  <abbr title="Avenue">AVE</abbr></p>]]></content>
      
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/test/hello-world/"/>
      <url>/test/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="http://zespia.tw/hexo" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="http://zespia.tw/hexo/docs" target="_blank" rel="noopener">documentation</a> to learn how to use.</p>]]></content>
      
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
